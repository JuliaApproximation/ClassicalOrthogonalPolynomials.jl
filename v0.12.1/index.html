<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Home ¬∑ ClassicalOrthogonalPolynomials.jl</title><meta name="title" content="Home ¬∑ ClassicalOrthogonalPolynomials.jl"/><meta property="og:title" content="Home ¬∑ ClassicalOrthogonalPolynomials.jl"/><meta property="twitter:title" content="Home ¬∑ ClassicalOrthogonalPolynomials.jl"/><meta name="description" content="Documentation for ClassicalOrthogonalPolynomials.jl."/><meta property="og:description" content="Documentation for ClassicalOrthogonalPolynomials.jl."/><meta property="twitter:description" content="Documentation for ClassicalOrthogonalPolynomials.jl."/><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="search_index.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href>ClassicalOrthogonalPolynomials.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>Home</a><ul class="internal"><li><a class="tocitem" href="#Definitions"><span>Definitions</span></a></li><li><a class="tocitem" href="#Evaluation"><span>Evaluation</span></a></li><li><a class="tocitem" href="#Continuum-arrays"><span>Continuum arrays</span></a></li><li><a class="tocitem" href="#Expansions"><span>Expansions</span></a></li><li><a class="tocitem" href="#Jacobi-matrices"><span>Jacobi matrices</span></a></li><li><a class="tocitem" href="#Derivatives"><span>Derivatives</span></a></li><li><a class="tocitem" href="#Other-recurrence-relationships"><span>Other recurrence relationships</span></a></li><li><a class="tocitem" href="#Index"><span>Index</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Home</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Home</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaApproximation/ClassicalOrthogonalPolynomials.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands">ÔÇõ</span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/JuliaApproximation/ClassicalOrthogonalPolynomials.jl/blob/main/docs/src/index.md" title="Edit source on GitHub"><span class="docs-icon fa-solid">ÔÅÑ</span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="ClassicalOrthogonalPolynomials.jl"><a class="docs-heading-anchor" href="#ClassicalOrthogonalPolynomials.jl">ClassicalOrthogonalPolynomials.jl</a><a id="ClassicalOrthogonalPolynomials.jl-1"></a><a class="docs-heading-anchor-permalink" href="#ClassicalOrthogonalPolynomials.jl" title="Permalink"></a></h1><p>A Julia package for classical orthogonal polynomials and expansions</p><h2 id="Definitions"><a class="docs-heading-anchor" href="#Definitions">Definitions</a><a id="Definitions-1"></a><a class="docs-heading-anchor-permalink" href="#Definitions" title="Permalink"></a></h2><p>We follow the <a href="https://dlmf.nist.gov/18.3">Digital Library of Mathematical Functions</a>, which defines the following classical orthogonal polynomials:</p><ol><li>Legendre: <code>P_n(x)</code></li><li>Chebyshev (1st kind, 2nd kind): <code>T_n(x)</code>, <code>U_n(x)</code></li><li>Ultraspherical: <code>C_n^{(Œª)}(x)</code></li><li>Jacobi: <code>P_n^{(a,b)}(x)</code></li><li>Laguerre: <code>L_n^{(Œ±)}(x)</code></li><li>Hermite: <code>H_n(x)</code></li></ol><h2 id="Evaluation"><a class="docs-heading-anchor" href="#Evaluation">Evaluation</a><a id="Evaluation-1"></a><a class="docs-heading-anchor-permalink" href="#Evaluation" title="Permalink"></a></h2><p>The simplest usage of this package is to evaluate classical orthogonal polynomials:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; using ClassicalOrthogonalPolynomials</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; n, x = 5, 0.1;</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; legendrep(n, x) # P_n(x)</code><code class="nohighlight hljs ansi" style="display:block;">0.17882875</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; chebyshevt(n, x) # T_n(x) == cos(n*acos(x))</code><code class="nohighlight hljs ansi" style="display:block;">0.48016</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; chebyshevu(n, x) # U_n(x) == sin((n+1)*acos(x))/sin(acos(x))</code><code class="nohighlight hljs ansi" style="display:block;">0.56832</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; Œª = 0.3; ultrasphericalc(n, Œª, x) # C_n^(Œª)(x)</code><code class="nohighlight hljs ansi" style="display:block;">0.08578714248</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; a,b = 0.1,0.2; jacobip(n, a, b, x) # P_n^(a,b)(x)</code><code class="nohighlight hljs ansi" style="display:block;">0.17459116797117194</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; laguerrel(n, x) # L_n(x)</code><code class="nohighlight hljs ansi" style="display:block;">0.5483540833333331</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; Œ± = 0.1; laguerrel(n, Œ±, x) # L_n^(Œ±)(x)</code><code class="nohighlight hljs ansi" style="display:block;">0.732916666666666</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; hermiteh(n, x) # H_n(x)</code><code class="nohighlight hljs ansi" style="display:block;">11.84032</code></pre><h2 id="Continuum-arrays"><a class="docs-heading-anchor" href="#Continuum-arrays">Continuum arrays</a><a id="Continuum-arrays-1"></a><a class="docs-heading-anchor-permalink" href="#Continuum-arrays" title="Permalink"></a></h2><p>For expansions, recurrence relationships, and other operations linked with linear equations, it is useful to treat the families of orthogonal  polynomials as <em>continuum arrays</em>, as implemented in <a href="https://github.com/JuliaApproximation/ContinuumArrays.jl">ContinuumArrays.jl</a>. The continuum arrays implementation is accessed as follows:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; T = ChebyshevT() # Or just Chebyshev()</code><code class="nohighlight hljs ansi" style="display:block;">ERROR: UndefVarError: `ChebyshevT` not defined</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; axes(T) # [-1,1] by 1:‚àû</code><code class="nohighlight hljs ansi" style="display:block;">ERROR: UndefVarError: `T` not defined</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; T[x, n+1] # T_n(x) = cos(n*acos(x))</code><code class="nohighlight hljs ansi" style="display:block;">ERROR: UndefVarError: `T` not defined</code></pre><p>We can thereby access many points and indices efficiently using array-like language:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; x = range(-1, 1; length=1000);</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; T[x, 1:1000] # [T_j(x[k]) for k=1:1000, j=0:999]</code><code class="nohighlight hljs ansi" style="display:block;">ERROR: UndefVarError: `T` not defined</code></pre><h2 id="Expansions"><a class="docs-heading-anchor" href="#Expansions">Expansions</a><a id="Expansions-1"></a><a class="docs-heading-anchor-permalink" href="#Expansions" title="Permalink"></a></h2><p>We view a function expansion in say Chebyshev polynomials in terms of continuum arrays as follows:</p><p class="math-container">\[f(x) = \sum_{k=0}^‚àû c_k T_k(x) = \begin{bmatrix}T_0(x) | T_1(x) | ‚Ä¶ \end{bmatrix} 
\begin{bmatrix}c_0\\ c_1 \\ \vdots \end{bmatrix} = T[x,:] * ùêú\]</p><p>To be more precise, we think of functions as continuum-vectors. Here is a simple example:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; f = T * [1; 2; 3; zeros(‚àû)]; # T_0(x) + T_1(x) + T_2(x)</code><code class="nohighlight hljs ansi" style="display:block;">ERROR: UndefVarError: `T` not defined</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; f[0.1]</code><code class="nohighlight hljs ansi" style="display:block;">ERROR: UndefVarError: `f` not defined</code></pre><p>To find the coefficients for a given function we consider this as the problem of finding <code>ùêú</code> such that <code>T*ùêú == f</code>, that is:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; T \ f</code><code class="nohighlight hljs ansi" style="display:block;">ERROR: UndefVarError: `T` not defined</code></pre><p>For a function given only pointwise we broadcast over <code>x</code>, e.g., the following are the coefficients of <code>\exp(x)</code>:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; x = axes(T, 1);</code><code class="nohighlight hljs ansi" style="display:block;">ERROR: UndefVarError: `T` not defined</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; c = T \ exp.(x)</code><code class="nohighlight hljs ansi" style="display:block;">ERROR: UndefVarError: `T` not defined</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; f = T*c; f[0.1] # ‚âà exp(0.1)</code><code class="nohighlight hljs ansi" style="display:block;">ERROR: UndefVarError: `T` not defined</code></pre><p>With a little cheeky usage of Julia&#39;s order-of-operations this can be written succicently as:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; f = T / T \ exp.(x);</code><code class="nohighlight hljs ansi" style="display:block;">ERROR: UndefVarError: `T` not defined</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; f[0.1]</code><code class="nohighlight hljs ansi" style="display:block;">ERROR: UndefVarError: `f` not defined</code></pre><p>(Or for more clarity just write <code>T * (T \ exp.(x))</code>.)</p><h2 id="Jacobi-matrices"><a class="docs-heading-anchor" href="#Jacobi-matrices">Jacobi matrices</a><a id="Jacobi-matrices-1"></a><a class="docs-heading-anchor-permalink" href="#Jacobi-matrices" title="Permalink"></a></h2><p>Orthogonal polynomials satisfy well-known three-term recurrences:</p><p class="math-container">\[x p_n(x) = c_{n-1} p_{n-1}(x) + a_n p_n(x) + b_n p_{n+1}(x).\]</p><p>In continuum-array language this has the  form of a comuting relationship:</p><p class="math-container">\[x \begin{bmatrix} p_0 | p_1 | \cdots \end{bmatrix} = \begin{bmatrix} p_0 | p_1 | \cdots \end{bmatrix} \begin{bmatrix} a_0 &amp; c_0  \\ b_0 &amp; a_1 &amp; c_1 \\ &amp; b_1 &amp; a_2 &amp; \ddots \\ &amp;&amp;\ddots &amp; \ddots \end{bmatrix}\]</p><p>We can therefore find the Jacobi matrix naturally as follows:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; T \ (x .* T)</code><code class="nohighlight hljs ansi" style="display:block;">ERROR: UndefVarError: `T` not defined</code></pre><p>Alternatively, just call <code>jacobimatrix(T)</code> (noting its the transpose of the more traditional convention).</p><h2 id="Derivatives"><a class="docs-heading-anchor" href="#Derivatives">Derivatives</a><a id="Derivatives-1"></a><a class="docs-heading-anchor-permalink" href="#Derivatives" title="Permalink"></a></h2><p>The derivatives of classical orthogonal polynomials are also classical OPs, and this can be seen as follows:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; U = ChebyshevU();</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; D = Derivative(x);</code><code class="nohighlight hljs ansi" style="display:block;">ERROR: MethodError: no method matching Derivative(::Float64)

Closest candidates are:
  Derivative(<span class="sgr91">::Inclusion{T, D}</span>) where {T, D}
<span class="sgr90">   @</span> <span class="sgr35">ContinuumArrays</span> <span class="sgr90">~/.julia/packages/ContinuumArrays/VkVcu/src/<span class="sgr4">operators.jl:118</span></span>
  Derivative(<span class="sgr91">::QuasiArrays.AbstractQuasiMatrix</span>)
<span class="sgr90">   @</span> <span class="sgr35">ContinuumArrays</span> <span class="sgr90">~/.julia/packages/ContinuumArrays/VkVcu/src/<span class="sgr4">operators.jl:124</span></span></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; U\D*T</code><code class="nohighlight hljs ansi" style="display:block;">ERROR: UndefVarError: `D` not defined</code></pre><p>Similarly, the derivative of <em>weighted</em> classical OPs are weighted classical OPs:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; Weighted(T)\D*Weighted(U)</code><code class="nohighlight hljs ansi" style="display:block;">ERROR: UndefVarError: `T` not defined</code></pre><h2 id="Other-recurrence-relationships"><a class="docs-heading-anchor" href="#Other-recurrence-relationships">Other recurrence relationships</a><a id="Other-recurrence-relationships-1"></a><a class="docs-heading-anchor-permalink" href="#Other-recurrence-relationships" title="Permalink"></a></h2><p>Many other sparse recurrence relationships are implemented. Here&#39;s one:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; U\T</code><code class="nohighlight hljs ansi" style="display:block;">ERROR: UndefVarError: `T` not defined</code></pre><p>(Probably best to ignore the type signature üòÖ)</p><h2 id="Index"><a class="docs-heading-anchor" href="#Index">Index</a><a id="Index-1"></a><a class="docs-heading-anchor-permalink" href="#Index" title="Permalink"></a></h2><h3 id="Polynomials"><a class="docs-heading-anchor" href="#Polynomials">Polynomials</a><a id="Polynomials-1"></a><a class="docs-heading-anchor-permalink" href="#Polynomials" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClassicalOrthogonalPolynomials.Chebyshev" href="#ClassicalOrthogonalPolynomials.Chebyshev"><code>ClassicalOrthogonalPolynomials.Chebyshev</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><p>Chebyshev{kind,T}()</p><p>is a quasi-matrix representing Chebyshev polynomials of the specified kind (1, 2, 3, or 4) on -1..1.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaApproximation/ClassicalOrthogonalPolynomials.jl/blob/d40aed86cf7309f9b5c58f0c4d9c99448ca61dbd/src/classical/chebyshev.jl#L19-L24">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClassicalOrthogonalPolynomials.chebyshevt" href="#ClassicalOrthogonalPolynomials.chebyshevt"><code>ClassicalOrthogonalPolynomials.chebyshevt</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs"> chebyshevt(n, z)</code></pre><p>computes the <code>n</code>-th Chebyshev polynomial of the first kind at <code>z</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaApproximation/ClassicalOrthogonalPolynomials.jl/blob/d40aed86cf7309f9b5c58f0c4d9c99448ca61dbd/src/classical/chebyshev.jl#L57-L61">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClassicalOrthogonalPolynomials.chebyshevu" href="#ClassicalOrthogonalPolynomials.chebyshevu"><code>ClassicalOrthogonalPolynomials.chebyshevu</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs"> chebyshevt(n, z)</code></pre><p>computes the <code>n</code>-th Chebyshev polynomial of the second kind at <code>z</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaApproximation/ClassicalOrthogonalPolynomials.jl/blob/d40aed86cf7309f9b5c58f0c4d9c99448ca61dbd/src/classical/chebyshev.jl#L63-L67">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClassicalOrthogonalPolynomials.legendrep" href="#ClassicalOrthogonalPolynomials.legendrep"><code>ClassicalOrthogonalPolynomials.legendrep</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs"> legendrep(n, z)</code></pre><p>computes the <code>n</code>-th Legendre polynomial at <code>z</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaApproximation/ClassicalOrthogonalPolynomials.jl/blob/d40aed86cf7309f9b5c58f0c4d9c99448ca61dbd/src/classical/legendre.jl#L65-L69">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClassicalOrthogonalPolynomials.jacobip" href="#ClassicalOrthogonalPolynomials.jacobip"><code>ClassicalOrthogonalPolynomials.jacobip</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs"> jacobip(n, a, b, z)</code></pre><p>computes the <code>n</code>-th Jacobi polynomial, orthogonal with respec to <code>(1-x)^a*(1+x)^b</code>, at <code>z</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaApproximation/ClassicalOrthogonalPolynomials.jl/blob/d40aed86cf7309f9b5c58f0c4d9c99448ca61dbd/src/classical/jacobi.jl#L110-L115">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClassicalOrthogonalPolynomials.laguerrel" href="#ClassicalOrthogonalPolynomials.laguerrel"><code>ClassicalOrthogonalPolynomials.laguerrel</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs"> laguerrel(n, Œ±, z)</code></pre><p>computes the <code>n</code>-th generalized Laguerre polynomial, orthogonal with  respec to <code>x^Œ± * exp(-x)</code>, at <code>z</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaApproximation/ClassicalOrthogonalPolynomials.jl/blob/d40aed86cf7309f9b5c58f0c4d9c99448ca61dbd/src/classical/laguerre.jl#L42-L47">source</a></section><section><div><pre><code class="language-julia hljs"> laguerrel(n, z)</code></pre><p>computes the <code>n</code>-th Laguerre polynomial, orthogonal with  respec to <code>exp(-x)</code>, at <code>z</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaApproximation/ClassicalOrthogonalPolynomials.jl/blob/d40aed86cf7309f9b5c58f0c4d9c99448ca61dbd/src/classical/laguerre.jl#L50-L55">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClassicalOrthogonalPolynomials.hermiteh" href="#ClassicalOrthogonalPolynomials.hermiteh"><code>ClassicalOrthogonalPolynomials.hermiteh</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs"> hermiteh(n, z)</code></pre><p>computes the <code>n</code>-th Hermite polynomial, orthogonal with  respec to <code>exp(-x^2)</code>, at <code>z</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaApproximation/ClassicalOrthogonalPolynomials.jl/blob/d40aed86cf7309f9b5c58f0c4d9c99448ca61dbd/src/classical/hermite.jl#L43-L48">source</a></section></article><h3 id="Weights"><a class="docs-heading-anchor" href="#Weights">Weights</a><a id="Weights-1"></a><a class="docs-heading-anchor-permalink" href="#Weights" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClassicalOrthogonalPolynomials.OrthonormalWeighted" href="#ClassicalOrthogonalPolynomials.OrthonormalWeighted"><code>ClassicalOrthogonalPolynomials.OrthonormalWeighted</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">OrthonormalWeighted(P)</code></pre><p>is the orthonormal with respect to L^2 basis given by <code>sqrt.(orthogonalityweight(P)) .* Normalized(P)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaApproximation/ClassicalOrthogonalPolynomials.jl/blob/d40aed86cf7309f9b5c58f0c4d9c99448ca61dbd/src/normalized.jl#L211-L216">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClassicalOrthogonalPolynomials.HermiteWeight" href="#ClassicalOrthogonalPolynomials.HermiteWeight"><code>ClassicalOrthogonalPolynomials.HermiteWeight</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><p>HermiteWeight()</p><p>is a quasi-vector representing <code>exp(-x^2)</code> on ‚Ñù.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaApproximation/ClassicalOrthogonalPolynomials.jl/blob/d40aed86cf7309f9b5c58f0c4d9c99448ca61dbd/src/classical/hermite.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClassicalOrthogonalPolynomials.Weighted" href="#ClassicalOrthogonalPolynomials.Weighted"><code>ClassicalOrthogonalPolynomials.Weighted</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Weighted(P)</code></pre><p>is equivalent to <code>orthogonalityweight(P) .* P</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaApproximation/ClassicalOrthogonalPolynomials.jl/blob/d40aed86cf7309f9b5c58f0c4d9c99448ca61dbd/src/normalized.jl#L239-L243">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClassicalOrthogonalPolynomials.ChebyshevWeight" href="#ClassicalOrthogonalPolynomials.ChebyshevWeight"><code>ClassicalOrthogonalPolynomials.ChebyshevWeight</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><p>ChebyshevWeight{kind,T}()</p><p>is a quasi-vector representing the Chebyshev weight of the specified kind on -1..1. That is, <code>ChebyshevWeight{1}()</code> represents <code>1/sqrt(1-x^2)</code>, and <code>ChebyshevWeight{2}()</code> represents <code>sqrt(1-x^2)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaApproximation/ClassicalOrthogonalPolynomials.jl/blob/d40aed86cf7309f9b5c58f0c4d9c99448ca61dbd/src/classical/chebyshev.jl#L1-L7">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClassicalOrthogonalPolynomials.LaguerreWeight" href="#ClassicalOrthogonalPolynomials.LaguerreWeight"><code>ClassicalOrthogonalPolynomials.LaguerreWeight</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><p>LaguerreWeight(Œ±)</p><p>is a quasi-vector representing <code>x^Œ± * exp(-x)</code> on <code>0..Inf</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaApproximation/ClassicalOrthogonalPolynomials.jl/blob/d40aed86cf7309f9b5c58f0c4d9c99448ca61dbd/src/classical/laguerre.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClassicalOrthogonalPolynomials.HalfWeighted" href="#ClassicalOrthogonalPolynomials.HalfWeighted"><code>ClassicalOrthogonalPolynomials.HalfWeighted</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">HalfWeighted{lr}(Jacobi(a,b))</code></pre><p>is equivalent to <code>JacobiWeight(a,0) .* Jacobi(a,b)</code> (<code>lr = :a</code>) or <code>JacobiWeight(0,b) .* Jacobi(a,b)</code> (<code>lr = :b</code>)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaApproximation/ClassicalOrthogonalPolynomials.jl/blob/d40aed86cf7309f9b5c58f0c4d9c99448ca61dbd/src/classical/jacobi.jl#L124-L129">source</a></section></article><h3 id="Recurrences"><a class="docs-heading-anchor" href="#Recurrences">Recurrences</a><a id="Recurrences-1"></a><a class="docs-heading-anchor-permalink" href="#Recurrences" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClassicalOrthogonalPolynomials.normalizationconstant" href="#ClassicalOrthogonalPolynomials.normalizationconstant"><code>ClassicalOrthogonalPolynomials.normalizationconstant</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><p>normalizationconstant</p><p>gives the normalization constants so that the jacobi matrix is symmetric, that is, so we have orthonormal OPs:</p><pre><code class="nohighlight hljs">Q == P*normalizationconstant(P)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaApproximation/ClassicalOrthogonalPolynomials.jl/blob/d40aed86cf7309f9b5c58f0c4d9c99448ca61dbd/src/normalized.jl#L1-L8">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClassicalOrthogonalPolynomials.OrthogonalPolynomialRatio" href="#ClassicalOrthogonalPolynomials.OrthogonalPolynomialRatio"><code>ClassicalOrthogonalPolynomials.OrthogonalPolynomialRatio</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">OrthogonalPolynomialRatio(P,x)</code></pre><p>is a is equivalent to the vector <code>P[x,:] ./ P[x,2:end]</code><code>but built from the recurrence coefficients of</code>P`.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaApproximation/ClassicalOrthogonalPolynomials.jl/blob/d40aed86cf7309f9b5c58f0c4d9c99448ca61dbd/src/ratios.jl#L1-L6">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClassicalOrthogonalPolynomials.Clenshaw" href="#ClassicalOrthogonalPolynomials.Clenshaw"><code>ClassicalOrthogonalPolynomials.Clenshaw</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Clenshaw(a, X)</code></pre><p>represents the operator <code>a(X)</code> where a is a polynomial. Here <code>a</code> is to stored as a quasi-vector.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaApproximation/ClassicalOrthogonalPolynomials.jl/blob/d40aed86cf7309f9b5c58f0c4d9c99448ca61dbd/src/clenshaw.jl#L247-L252">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClassicalOrthogonalPolynomials.singularities" href="#ClassicalOrthogonalPolynomials.singularities"><code>ClassicalOrthogonalPolynomials.singularities</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">singularities(f)</code></pre><p>gives the singularity structure of an expansion, e.g., <code>JacobiWeight</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaApproximation/ClassicalOrthogonalPolynomials.jl/blob/d40aed86cf7309f9b5c58f0c4d9c99448ca61dbd/src/ClassicalOrthogonalPolynomials.jl#L197-L202">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClassicalOrthogonalPolynomials.jacobimatrix" href="#ClassicalOrthogonalPolynomials.jacobimatrix"><code>ClassicalOrthogonalPolynomials.jacobimatrix</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">jacobimatrix(P)</code></pre><p>returns the Jacobi matrix <code>X</code> associated to a quasi-matrix of orthogonal polynomials satisfying</p><pre><code class="language-julia hljs">x = axes(P,1)
x*P == P*X</code></pre><p>Note that <code>X</code> is the transpose of the usual definition of the Jacobi matrix.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaApproximation/ClassicalOrthogonalPolynomials.jl/blob/d40aed86cf7309f9b5c58f0c4d9c99448ca61dbd/src/ClassicalOrthogonalPolynomials.jl#L132-L142">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClassicalOrthogonalPolynomials.recurrencecoefficients" href="#ClassicalOrthogonalPolynomials.recurrencecoefficients"><code>ClassicalOrthogonalPolynomials.recurrencecoefficients</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">recurrencecoefficients(P)</code></pre><p>returns a <code>(A,B,C)</code> associated with the Orthogonal Polynomials P, satisfying for <code>x in axes(P,1)</code></p><pre><code class="language-julia hljs">P[x,2] == (A[1]*x + B[1])*P[x,1]
P[x,n+1] == (A[n]*x + B[n])*P[x,n] - C[n]*P[x,n-1]</code></pre><p>Note that <code>C[1]</code>` is unused.</p><p>The relationship with the Jacobi matrix is:</p><pre><code class="language-julia hljs">1/A[n] == X[n+1,n]
-B[n]/A[n] == X[n,n]
C[n+1]/A[n+1] == X[n,n+1]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaApproximation/ClassicalOrthogonalPolynomials.jl/blob/d40aed86cf7309f9b5c58f0c4d9c99448ca61dbd/src/ClassicalOrthogonalPolynomials.jl#L175-L192">source</a></section></article><h3 id="Internal"><a class="docs-heading-anchor" href="#Internal">Internal</a><a id="Internal-1"></a><a class="docs-heading-anchor-permalink" href="#Internal" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClassicalOrthogonalPolynomials.ShuffledIR2HC" href="#ClassicalOrthogonalPolynomials.ShuffledIR2HC"><code>ClassicalOrthogonalPolynomials.ShuffledIR2HC</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><p>Gives a shuffled version of the real IFFT, with order 1,sin(Œ∏),cos(Œ∏),sin(2Œ∏)‚Ä¶</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaApproximation/ClassicalOrthogonalPolynomials.jl/blob/d40aed86cf7309f9b5c58f0c4d9c99448ca61dbd/src/classical/fourier.jl#L40-L43">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClassicalOrthogonalPolynomials.ShuffledR2HC" href="#ClassicalOrthogonalPolynomials.ShuffledR2HC"><code>ClassicalOrthogonalPolynomials.ShuffledR2HC</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><p>Gives a shuffled version of the real FFT, with order 1,sin(Œ∏),cos(Œ∏),sin(2Œ∏)‚Ä¶</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaApproximation/ClassicalOrthogonalPolynomials.jl/blob/d40aed86cf7309f9b5c58f0c4d9c99448ca61dbd/src/classical/fourier.jl#L32-L35">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClassicalOrthogonalPolynomials.ShuffledIFFT" href="#ClassicalOrthogonalPolynomials.ShuffledIFFT"><code>ClassicalOrthogonalPolynomials.ShuffledIFFT</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><p>Gives a shuffled version of the IFFT, with order 1,sin(Œ∏),cos(Œ∏),sin(2Œ∏)‚Ä¶</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaApproximation/ClassicalOrthogonalPolynomials.jl/blob/d40aed86cf7309f9b5c58f0c4d9c99448ca61dbd/src/classical/fourier.jl#L56-L59">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClassicalOrthogonalPolynomials.qr_jacobimatrix" href="#ClassicalOrthogonalPolynomials.qr_jacobimatrix"><code>ClassicalOrthogonalPolynomials.qr_jacobimatrix</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><p>qr_jacobimatrix(sqrtw, P)</p><p>returns the Jacobi matrix <code>X</code> associated to a quasi-matrix of polynomials orthogonal with respect to <code>w(x) w_p(x)</code> where <code>w_p(x)</code> is the weight of the polynomials in <code>P</code> by computing a QR decomposition of the square root weight modification.</p><p>The resulting polynomials are orthonormal on the same domain as <code>P</code>. The supplied <code>P</code> must be normalized. Accepted inputs for <code>sqrtw</code> are the square root of the weight modification as a function or <code>sqrtW</code> as an infinite matrix representing multiplication with the function <code>sqrt(w)</code> on the basis <code>P</code>.</p><p>The underlying QR approach allows two methods, one which uses the Q matrix and one which uses the R matrix. To change between methods, an optional argument :Q or :R may be supplied. The default is to use the Q method.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaApproximation/ClassicalOrthogonalPolynomials.jl/blob/d40aed86cf7309f9b5c58f0c4d9c99448ca61dbd/src/choleskyQR.jl#L115-L124">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClassicalOrthogonalPolynomials.MappedOPLayout" href="#ClassicalOrthogonalPolynomials.MappedOPLayout"><code>ClassicalOrthogonalPolynomials.MappedOPLayout</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">MappedOPLayout</code></pre><p>represents an OP that is (usually affine) mapped OP</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaApproximation/ClassicalOrthogonalPolynomials.jl/blob/d40aed86cf7309f9b5c58f0c4d9c99448ca61dbd/src/ClassicalOrthogonalPolynomials.jl#L78-L82">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClassicalOrthogonalPolynomials.cholesky_jacobimatrix" href="#ClassicalOrthogonalPolynomials.cholesky_jacobimatrix"><code>ClassicalOrthogonalPolynomials.cholesky_jacobimatrix</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><p>cholesky_jacobimatrix(w, P)</p><p>returns the Jacobi matrix <code>X</code> associated to a quasi-matrix of polynomials orthogonal with respect to <code>w(x) w_p(x)</code> where <code>w_p(x)</code> is the weight of the polynomials in <code>P</code> by computing a Cholesky decomposition of the weight modification.</p><p>The resulting polynomials are orthonormal on the same domain as <code>P</code>. The supplied <code>P</code> must be normalized. Accepted inputs are <code>w</code> as a function or <code>W</code> as an infinite matrix representing multiplication with the function <code>w</code> on the basis <code>P</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaApproximation/ClassicalOrthogonalPolynomials.jl/blob/d40aed86cf7309f9b5c58f0c4d9c99448ca61dbd/src/choleskyQR.jl#L34-L41">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClassicalOrthogonalPolynomials.AbstractNormalizedOPLayout" href="#ClassicalOrthogonalPolynomials.AbstractNormalizedOPLayout"><code>ClassicalOrthogonalPolynomials.AbstractNormalizedOPLayout</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AbstractNormalizedOPLayout</code></pre><p>represents OPs that are of the form P * R where P is another family of OPs and R is upper-triangular.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaApproximation/ClassicalOrthogonalPolynomials.jl/blob/d40aed86cf7309f9b5c58f0c4d9c99448ca61dbd/src/normalized.jl#L32-L36">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClassicalOrthogonalPolynomials.ShuffledFFT" href="#ClassicalOrthogonalPolynomials.ShuffledFFT"><code>ClassicalOrthogonalPolynomials.ShuffledFFT</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><p>Gives a shuffled version of the FFT, with order 1,sin(Œ∏),cos(Œ∏),sin(2Œ∏)‚Ä¶</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaApproximation/ClassicalOrthogonalPolynomials.jl/blob/d40aed86cf7309f9b5c58f0c4d9c99448ca61dbd/src/classical/fourier.jl#L48-L51">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClassicalOrthogonalPolynomials.legendre_grammatrix" href="#ClassicalOrthogonalPolynomials.legendre_grammatrix"><code>ClassicalOrthogonalPolynomials.legendre_grammatrix</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">legendre_grammatrix</code></pre><p>computes the grammatrix by first re-expanding in Legendre</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaApproximation/ClassicalOrthogonalPolynomials.jl/blob/d40aed86cf7309f9b5c58f0c4d9c99448ca61dbd/src/classical/legendre.jl#L104-L108">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClassicalOrthogonalPolynomials.WeightedOPLayout" href="#ClassicalOrthogonalPolynomials.WeightedOPLayout"><code>ClassicalOrthogonalPolynomials.WeightedOPLayout</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">WeightedOPLayout</code></pre><p>represents an OP multiplied by its orthogonality weight.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaApproximation/ClassicalOrthogonalPolynomials.jl/blob/d40aed86cf7309f9b5c58f0c4d9c99448ca61dbd/src/ClassicalOrthogonalPolynomials.jl#L85-L89">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClassicalOrthogonalPolynomials.interlace!" href="#ClassicalOrthogonalPolynomials.interlace!"><code>ClassicalOrthogonalPolynomials.interlace!</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><p>This function implements the algorithm described in:</p><pre><code class="nohighlight hljs">P. Jain, &quot;A simple in-place algorithm for in-shuffle,&quot; arXiv:0805.1598, 2008.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaApproximation/ClassicalOrthogonalPolynomials.jl/blob/d40aed86cf7309f9b5c58f0c4d9c99448ca61dbd/src/interlace.jl#L63-L67">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClassicalOrthogonalPolynomials._tritrunc" href="#ClassicalOrthogonalPolynomials._tritrunc"><code>ClassicalOrthogonalPolynomials._tritrunc</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">_tritrunc(X,n)</code></pre><p>does a square truncation of a tridiagonal matrix.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaApproximation/ClassicalOrthogonalPolynomials.jl/blob/d40aed86cf7309f9b5c58f0c4d9c99448ca61dbd/src/ClassicalOrthogonalPolynomials.jl#L148-L152">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClassicalOrthogonalPolynomials.SetindexInterlace" href="#ClassicalOrthogonalPolynomials.SetindexInterlace"><code>ClassicalOrthogonalPolynomials.SetindexInterlace</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SetindexInterlace(z, args...)</code></pre><p>is an analogue of <code>Basis</code> for vector that replaces the <code>i</code>th index of <code>z</code>, takes the union of the first axis, and the second axis is a blocked interlace of args.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaApproximation/ClassicalOrthogonalPolynomials.jl/blob/d40aed86cf7309f9b5c58f0c4d9c99448ca61dbd/src/interlace.jl#L128-L135">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClassicalOrthogonalPolynomials.ConvertedOrthogonalPolynomial" href="#ClassicalOrthogonalPolynomials.ConvertedOrthogonalPolynomial"><code>ClassicalOrthogonalPolynomials.ConvertedOrthogonalPolynomial</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><p>Represent an Orthogonal polynomial which has a conversion operator from P, that is, Q = P * inv(U).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaApproximation/ClassicalOrthogonalPolynomials.jl/blob/d40aed86cf7309f9b5c58f0c4d9c99448ca61dbd/src/choleskyQR.jl#L1-L3">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ClassicalOrthogonalPolynomials.PiecewiseInterlace" href="#ClassicalOrthogonalPolynomials.PiecewiseInterlace"><code>ClassicalOrthogonalPolynomials.PiecewiseInterlace</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">PiecewiseInterlace(args...)</code></pre><p>is an analogue of <code>Basis</code> that takes the union of the first axis, and the second axis is a blocked interlace of args. If there is overlap, it uses the first in order.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaApproximation/ClassicalOrthogonalPolynomials.jl/blob/d40aed86cf7309f9b5c58f0c4d9c99448ca61dbd/src/interlace.jl#L105-L111">source</a></section></article></article><nav class="docs-footer"><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="auto">Automatic (OS)</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.2.1 on <span class="colophon-date" title="Monday 4 December 2023 22:26">Monday 4 December 2023</span>. Using Julia version 1.9.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
