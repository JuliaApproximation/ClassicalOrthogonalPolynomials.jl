<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Home Â· ClassicalOrthogonalPolynomials.jl</title><meta name="title" content="Home Â· ClassicalOrthogonalPolynomials.jl"/><meta property="og:title" content="Home Â· ClassicalOrthogonalPolynomials.jl"/><meta property="twitter:title" content="Home Â· ClassicalOrthogonalPolynomials.jl"/><meta name="description" content="Documentation for ClassicalOrthogonalPolynomials.jl."/><meta property="og:description" content="Documentation for ClassicalOrthogonalPolynomials.jl."/><meta property="twitter:description" content="Documentation for ClassicalOrthogonalPolynomials.jl."/><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="search_index.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href>ClassicalOrthogonalPolynomials.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>Home</a><ul class="internal"><li><a class="tocitem" href="#Definitions"><span>Definitions</span></a></li><li><a class="tocitem" href="#Evaluation"><span>Evaluation</span></a></li><li><a class="tocitem" href="#Continuum-arrays"><span>Continuum arrays</span></a></li><li><a class="tocitem" href="#Expansions"><span>Expansions</span></a></li><li><a class="tocitem" href="#Jacobi-matrices"><span>Jacobi matrices</span></a></li><li><a class="tocitem" href="#Derivatives"><span>Derivatives</span></a></li><li><a class="tocitem" href="#Other-recurrence-relationships"><span>Other recurrence relationships</span></a></li><li><a class="tocitem" href="#Index"><span>Index</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Home</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Home</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaApproximation/ClassicalOrthogonalPolynomials.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands">ï‚›</span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/JuliaApproximation/ClassicalOrthogonalPolynomials.jl/blob/main/docs/src/index.md" title="Edit source on GitHub"><span class="docs-icon fa-solid">ï„</span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="ClassicalOrthogonalPolynomials.jl"><a class="docs-heading-anchor" href="#ClassicalOrthogonalPolynomials.jl">ClassicalOrthogonalPolynomials.jl</a><a id="ClassicalOrthogonalPolynomials.jl-1"></a><a class="docs-heading-anchor-permalink" href="#ClassicalOrthogonalPolynomials.jl" title="Permalink"></a></h1><p>A Julia package for classical orthogonal polynomials and expansions</p><h2 id="Definitions"><a class="docs-heading-anchor" href="#Definitions">Definitions</a><a id="Definitions-1"></a><a class="docs-heading-anchor-permalink" href="#Definitions" title="Permalink"></a></h2><p>We follow the <a href="https://dlmf.nist.gov/18.3">Digital Library of Mathematical Functions</a>, which defines the following classical orthogonal polynomials:</p><ol><li>Legendre: <span>$P_n(x)$</span>, defined over <span>$[-1, 1]$</span> with weight <span>$w(x) = 1$</span>.</li><li>Chebyshev (1st kind, 2nd kind): <span>$T_n(x)$</span> and <span>$U_n(x)$</span>, defined over <span>$[-1, 1]$</span> with weights <span>$w(x) = 1/\sqrt{1-x^2}$</span> and <span>$w(x) = \sqrt{1-x^2}$</span>, respectively.</li><li>Ultraspherical: <span>$C_n^{(\lambda)}(x)$</span>, defined over <span>$[-1, 1]$</span> with weight <span>$w(x) = (1-x^2)^{\lambda-1/2}$</span>.</li><li>Jacobi: <span>$P_n^{(a,b)}(x)$</span>, defined over <span>$[-1, 1]$</span> with weight <span>$w(x) = (1-x)^a(1+x)^b$</span>.</li><li>Laguerre: <span>$L_n^{(\alpha)}(x)$</span>, defined over <span>$[0, âˆ)$</span> with weight <span>$w(x) = x^\alpha \mathrm{e}^{-x}$</span>.</li><li>Hermite: <span>$H_n(x)$</span>, defined over <span>$(-âˆ, âˆ)$</span> with weight <span>$w(x) = \mathrm{e}^{-x^2}$</span>.</li></ol><p>These special polynomials have many applications and can be used as a basis for any function given their domain conditions are met, however these polynomials have some advantages due to their formulation:</p><ul><li>Because of their relation to Laplaceâ€™s equation, <strong>Legendre polynomials</strong> can be useful as a basis for functions with spherical symmetry.</li><li><strong>Chebyshev polynomials</strong> are generally effective in reducing errors from numerical methods such as quadrature, interpolation, and approximation.</li><li>Due to the flexibility of its parameters, <strong>Jacobi polynomials</strong> are capable of tailoring the behavior of an approximation around its endpoints, making these polynomials particularly useful in boundary value problems.</li><li><strong>Ultraspherical polynomials</strong> are advantageous in spectral methods for solving differential equations.</li><li><strong>Laguerre polynomials</strong> have a semi-infinite domain, therefore they are beneficial for problems involving exponential decay.</li><li>Because of its weight function, <strong>Hermite polynomials</strong> can be useful in situations where functions display a Gaussian-like distribution.</li></ul><p>These are just a few applications of these polynomials. They have many more uses across mathematics, physics, and engineering.</p><h2 id="Evaluation"><a class="docs-heading-anchor" href="#Evaluation">Evaluation</a><a id="Evaluation-1"></a><a class="docs-heading-anchor-permalink" href="#Evaluation" title="Permalink"></a></h2><p>The simplest usage of this package is to evaluate classical orthogonal polynomials:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; using ClassicalOrthogonalPolynomials</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; n, x = 5, 0.1;</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; legendrep(n, x) # P_n(x)</code><code class="nohighlight hljs ansi" style="display:block;">0.17882875</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; chebyshevt(n, x) # T_n(x) == cos(n*acos(x))</code><code class="nohighlight hljs ansi" style="display:block;">0.48016</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; chebyshevu(n, x) # U_n(x) == sin((n+1)*acos(x))/sin(acos(x))</code><code class="nohighlight hljs ansi" style="display:block;">0.56832</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; Î» = 0.3; ultrasphericalc(n, Î», x) # C_n^(Î»)(x)</code><code class="nohighlight hljs ansi" style="display:block;">0.08578714248</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; a,b = 0.1,0.2; jacobip(n, a, b, x) # P_n^(a,b)(x)</code><code class="nohighlight hljs ansi" style="display:block;">0.17459116797117194</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; laguerrel(n, x) # L_n(x)</code><code class="nohighlight hljs ansi" style="display:block;">0.5483540833333331</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; Î± = 0.1; laguerrel(n, Î±, x) # L_n^(Î±)(x)</code><code class="nohighlight hljs ansi" style="display:block;">0.732916666666666</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; hermiteh(n, x) # H_n(x)</code><code class="nohighlight hljs ansi" style="display:block;">11.84032</code></pre><h2 id="Continuum-arrays"><a class="docs-heading-anchor" href="#Continuum-arrays">Continuum arrays</a><a id="Continuum-arrays-1"></a><a class="docs-heading-anchor-permalink" href="#Continuum-arrays" title="Permalink"></a></h2><p>For expansions, recurrence relationships, and other operations linked with linear equations, it is useful to treat the families of orthogonal  polynomials as <em>continuum arrays</em>, as implemented in <a href="https://github.com/JuliaApproximation/ContinuumArrays.jl">ContinuumArrays.jl</a>. The continuum arrays implementation is accessed as follows:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; T = ChebyshevT() # Or just Chebyshev()</code><code class="nohighlight hljs ansi" style="display:block;">ChebyshevT()</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; axes(T) # [-1,1] by 1:âˆ</code><code class="nohighlight hljs ansi" style="display:block;">(Inclusion(-1.0 .. 1.0 (Chebyshev)), OneToInf())</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; T[x, n+1] # T_n(x) = cos(n*acos(x))</code><code class="nohighlight hljs ansi" style="display:block;">0.48016</code></pre><p>We can thereby access many points and indices efficiently using array-like language:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; x = range(-1, 1; length=1000);</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; T[x, 1:1000] # [T_j(x[k]) for k=1:1000, j=0:999]</code><code class="nohighlight hljs ansi" style="display:block;">1000Ã—1000 Matrix{Float64}:
 1.0  -1.0       1.0       -1.0       â€¦  -1.0        1.0       -1.0
 1.0  -0.997998  0.992     -0.98203      -0.964818   0.946258  -0.92391
 1.0  -0.995996  0.984016  -0.964156     -0.282676   0.195792  -0.107341
 1.0  -0.993994  0.976048  -0.946378      0.807761  -0.867423   0.916664
 1.0  -0.991992  0.968096  -0.928695     -0.827934   0.750471  -0.660989
 1.0  -0.98999   0.96016   -0.911108  â€¦   0.982736  -0.999011   0.995286
 1.0  -0.987988  0.952241  -0.893616      0.73242   -0.618409   0.489542
 1.0  -0.985986  0.944337  -0.87622       0.822718  -0.716355   0.589914
 1.0  -0.983984  0.936449  -0.858918      0.923481  -0.977078   0.999377
 1.0  -0.981982  0.928577  -0.84171      -0.495939   0.322905  -0.138236
 â‹®                                    â‹±
 1.0   0.983984  0.936449   0.858918     -0.923481  -0.977078  -0.999377
 1.0   0.985986  0.944337   0.87622      -0.822718  -0.716355  -0.589914
 1.0   0.987988  0.952241   0.893616     -0.73242   -0.618409  -0.489542
 1.0   0.98999   0.96016    0.911108     -0.982736  -0.999011  -0.995286
 1.0   0.991992  0.968096   0.928695  â€¦   0.827934   0.750471   0.660989
 1.0   0.993994  0.976048   0.946378     -0.807761  -0.867423  -0.916664
 1.0   0.995996  0.984016   0.964156      0.282676   0.195792   0.107341
 1.0   0.997998  0.992      0.98203       0.964818   0.946258   0.92391
 1.0   1.0       1.0        1.0           1.0        1.0        1.0</code></pre><h2 id="Expansions"><a class="docs-heading-anchor" href="#Expansions">Expansions</a><a id="Expansions-1"></a><a class="docs-heading-anchor-permalink" href="#Expansions" title="Permalink"></a></h2><p>We view a function expansion in say Chebyshev polynomials in terms of continuum arrays as follows:</p><p class="math-container">\[f(x) = \sum_{k=0}^âˆ c_k T_k(x) = \begin{bmatrix}T_0(x) | T_1(x) | â€¦ \end{bmatrix} 
\begin{bmatrix}c_0\\ c_1 \\ \vdots \end{bmatrix} = T[x,:] * ğœ\]</p><p>To be more precise, we think of functions as continuum-vectors. Here is a simple example:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; f = T * [1; 2; 3; zeros(âˆ)]; # T_0(x) + T_1(x) + T_2(x)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; f[0.1]</code><code class="nohighlight hljs ansi" style="display:block;">-1.74</code></pre><p>To find the coefficients for a given function we consider this as the problem of finding <code>ğœ</code> such that <code>T*ğœ == f</code>, that is:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; T \ f</code><code class="nohighlight hljs ansi" style="display:block;">â„µâ‚€-element LazyArrays.CachedArray{Float64, 1, Vector{Float64}, FillArrays.Zeros{Float64, 1, Tuple{InfiniteArrays.OneToInf{Int64}}}} with indices OneToInf():
 1.0
 2.0
 3.0
 0.0
 0.0
 0.0
 0.0
 0.0
 0.0
 0.0
 â‹®</code></pre><p>For a function given only pointwise we broadcast over <code>x</code>, e.g., the following are the coefficients of <code>\exp(x)</code>:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; x = axes(T, 1);</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; c = T \ exp.(x)</code><code class="nohighlight hljs ansi" style="display:block;">vcat(14-element Vector{Float64}, â„µâ‚€-element FillArrays.Zeros{Float64, 1, Tuple{InfiniteArrays.OneToInf{Int64}}} with indices OneToInf()) with indices OneToInf():
 1.2660658777520084
 1.1303182079849703
 0.27149533953407656
 0.04433684984866379
 0.0054742404420936785
 0.0005429263119139232
 4.497732295427654e-5
 3.19843646253781e-6
 1.992124804817033e-7
 1.1036771869970875e-8
 â‹®</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; f = T*c; f[0.1] # â‰ˆ exp(0.1)</code><code class="nohighlight hljs ansi" style="display:block;">1.1051709180756477</code></pre><p>With a little cheeky usage of Julia&#39;s order-of-operations this can be written succicently as:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; f = T / T \ exp.(x);</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; f[0.1]</code><code class="nohighlight hljs ansi" style="display:block;">1.1051709180756477</code></pre><p>(Or for more clarity just write <code>T * (T \ exp.(x))</code>.)</p><h2 id="Jacobi-matrices"><a class="docs-heading-anchor" href="#Jacobi-matrices">Jacobi matrices</a><a id="Jacobi-matrices-1"></a><a class="docs-heading-anchor-permalink" href="#Jacobi-matrices" title="Permalink"></a></h2><p>Orthogonal polynomials satisfy well-known three-term recurrences:</p><p class="math-container">\[x p_n(x) = c_{n-1} p_{n-1}(x) + a_n p_n(x) + b_n p_{n+1}(x).\]</p><p>In continuum-array language this has the  form of a comuting relationship:</p><p class="math-container">\[x \begin{bmatrix} p_0 | p_1 | \cdots \end{bmatrix} = \begin{bmatrix} p_0 | p_1 | \cdots \end{bmatrix} \begin{bmatrix} a_0 &amp; c_0  \\ b_0 &amp; a_1 &amp; c_1 \\ &amp; b_1 &amp; a_2 &amp; \ddots \\ &amp;&amp;\ddots &amp; \ddots \end{bmatrix}\]</p><p>We can therefore find the Jacobi matrix naturally as follows:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; T \ (x .* T)</code><code class="nohighlight hljs ansi" style="display:block;">â„µâ‚€Ã—â„µâ‚€ LazyBandedMatrices.Tridiagonal{Float64, LazyArrays.ApplyArray{Float64, 1, typeof(vcat), Tuple{Float64, FillArrays.Fill{Float64, 1, Tuple{InfiniteArrays.OneToInf{Int64}}}}}, FillArrays.Zeros{Float64, 1, Tuple{InfiniteArrays.OneToInf{Int64}}}, FillArrays.Fill{Float64, 1, Tuple{InfiniteArrays.OneToInf{Int64}}}} with indices OneToInf()Ã—OneToInf():
 0.0  0.5   â‹…    â‹…    â‹…    â‹…    â‹…    â‹…   â€¦
 1.0  0.0  0.5   â‹…    â‹…    â‹…    â‹…    â‹…
  â‹…   0.5  0.0  0.5   â‹…    â‹…    â‹…    â‹…
  â‹…    â‹…   0.5  0.0  0.5   â‹…    â‹…    â‹…
  â‹…    â‹…    â‹…   0.5  0.0  0.5   â‹…    â‹…
  â‹…    â‹…    â‹…    â‹…   0.5  0.0  0.5   â‹…   â€¦
  â‹…    â‹…    â‹…    â‹…    â‹…   0.5  0.0  0.5
  â‹…    â‹…    â‹…    â‹…    â‹…    â‹…   0.5  0.0
  â‹…    â‹…    â‹…    â‹…    â‹…    â‹…    â‹…   0.5
  â‹…    â‹…    â‹…    â‹…    â‹…    â‹…    â‹…    â‹…
 â‹®                        â‹®              â‹±</code></pre><p>Alternatively, just call <code>jacobimatrix(T)</code> (noting its the transpose of the more traditional convention).</p><h2 id="Derivatives"><a class="docs-heading-anchor" href="#Derivatives">Derivatives</a><a id="Derivatives-1"></a><a class="docs-heading-anchor-permalink" href="#Derivatives" title="Permalink"></a></h2><p>The derivatives of classical orthogonal polynomials are also classical OPs, and this can be seen as follows:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; U = ChebyshevU();</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; D = Derivative(x);</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; U\D*T</code><code class="nohighlight hljs ansi" style="display:block;">â„µâ‚€Ã—â„µâ‚€ BandedMatrix{Float64} with bandwidths (-1, 1) with data 1Ã—â„µâ‚€ adjoint(::InfiniteArrays.InfStepRange{Float64, Float64}) with eltype Float64 with indices Base.OneTo(1)Ã—OneToInf() with indices OneToInf()Ã—OneToInf():
  â‹…   1.0   â‹…    â‹…    â‹…    â‹…    â‹…    â‹…   â€¦
  â‹…    â‹…   2.0   â‹…    â‹…    â‹…    â‹…    â‹…
  â‹…    â‹…    â‹…   3.0   â‹…    â‹…    â‹…    â‹…
  â‹…    â‹…    â‹…    â‹…   4.0   â‹…    â‹…    â‹…
  â‹…    â‹…    â‹…    â‹…    â‹…   5.0   â‹…    â‹…
  â‹…    â‹…    â‹…    â‹…    â‹…    â‹…   6.0   â‹…   â€¦
  â‹…    â‹…    â‹…    â‹…    â‹…    â‹…    â‹…   7.0
  â‹…    â‹…    â‹…    â‹…    â‹…    â‹…    â‹…    â‹…
  â‹…    â‹…    â‹…    â‹…    â‹…    â‹…    â‹…    â‹…
  â‹…    â‹…    â‹…    â‹…    â‹…    â‹…    â‹…    â‹…
 â‹®                        â‹®              â‹±</code></pre><p>Similarly, the derivative of <em>weighted</em> classical OPs are weighted classical OPs:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; Weighted(T)\D*Weighted(U)</code><code class="nohighlight hljs ansi" style="display:block;">â„µâ‚€Ã—â„µâ‚€ BandedMatrix{Float64} with bandwidths (1, -1) with data 1Ã—â„µâ‚€ adjoint(::InfiniteArrays.InfStepRange{Float64, Float64}) with eltype Float64 with indices Base.OneTo(1)Ã—OneToInf() with indices OneToInf()Ã—OneToInf():
   â‹…     â‹…     â‹…     â‹…     â‹…     â‹…   â€¦
 -1.0    â‹…     â‹…     â‹…     â‹…     â‹…
   â‹…   -2.0    â‹…     â‹…     â‹…     â‹…
   â‹…     â‹…   -3.0    â‹…     â‹…     â‹…
   â‹…     â‹…     â‹…   -4.0    â‹…     â‹…
   â‹…     â‹…     â‹…     â‹…   -5.0    â‹…   â€¦
   â‹…     â‹…     â‹…     â‹…     â‹…   -6.0
   â‹…     â‹…     â‹…     â‹…     â‹…     â‹…
   â‹…     â‹…     â‹…     â‹…     â‹…     â‹…
   â‹…     â‹…     â‹…     â‹…     â‹…     â‹…
  â‹®                             â‹®    â‹±</code></pre><h2 id="Other-recurrence-relationships"><a class="docs-heading-anchor" href="#Other-recurrence-relationships">Other recurrence relationships</a><a id="Other-recurrence-relationships-1"></a><a class="docs-heading-anchor-permalink" href="#Other-recurrence-relationships" title="Permalink"></a></h2><p>Many other sparse recurrence relationships are implemented. Here&#39;s one:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; U\T</code><code class="nohighlight hljs ansi" style="display:block;">â„µâ‚€Ã—â„µâ‚€ BandedMatrix{Float64} with bandwidths (0, 2) with data vcat(1Ã—â„µâ‚€ FillArrays.Fill{Float64, 2, Tuple{Base.OneTo{Int64}, InfiniteArrays.OneToInf{Int64}}} with indices Base.OneTo(1)Ã—OneToInf(), 1Ã—â„µâ‚€ FillArrays.Zeros{Float64, 2, Tuple{Base.OneTo{Int64}, InfiniteArrays.OneToInf{Int64}}} with indices Base.OneTo(1)Ã—OneToInf(), hcat(1Ã—1 Ones{Float64}, 1Ã—â„µâ‚€ FillArrays.Fill{Float64, 2, Tuple{Base.OneTo{Int64}, InfiniteArrays.OneToInf{Int64}}} with indices Base.OneTo(1)Ã—OneToInf()) with indices Base.OneTo(1)Ã—OneToInf()) with indices Base.OneTo(3)Ã—OneToInf() with indices OneToInf()Ã—OneToInf():
 1.0  0.0  -0.5    â‹…     â‹…     â‹…     â‹…   â€¦
  â‹…   0.5   0.0  -0.5    â‹…     â‹…     â‹…
  â‹…    â‹…    0.5   0.0  -0.5    â‹…     â‹…
  â‹…    â‹…     â‹…    0.5   0.0  -0.5    â‹…
  â‹…    â‹…     â‹…     â‹…    0.5   0.0  -0.5
  â‹…    â‹…     â‹…     â‹…     â‹…    0.5   0.0  â€¦
  â‹…    â‹…     â‹…     â‹…     â‹…     â‹…    0.5
  â‹…    â‹…     â‹…     â‹…     â‹…     â‹…     â‹…
  â‹…    â‹…     â‹…     â‹…     â‹…     â‹…     â‹…
  â‹…    â‹…     â‹…     â‹…     â‹…     â‹…     â‹…
 â‹®                            â‹®          â‹±</code></pre><p>(Probably best to ignore the type signature ğŸ˜…)</p><h2 id="Index"><a class="docs-heading-anchor" href="#Index">Index</a><a id="Index-1"></a><a class="docs-heading-anchor-permalink" href="#Index" title="Permalink"></a></h2><h3 id="Polynomials"><a class="docs-heading-anchor" href="#Polynomials">Polynomials</a><a id="Polynomials-1"></a><a class="docs-heading-anchor-permalink" href="#Polynomials" title="Permalink"></a></h3><article><details class="docstring" open="true"><summary id="ClassicalOrthogonalPolynomials.Chebyshev"><a class="docstring-binding" href="#ClassicalOrthogonalPolynomials.Chebyshev"><code>ClassicalOrthogonalPolynomials.Chebyshev</code></a> â€” <span class="docstring-category">Type</span></summary><section><div><p>Chebyshev{kind,T}()</p><p>is a quasi-matrix representing Chebyshev polynomials of the specified kind (1, 2, 3, or 4) on -1..1.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaApproximation/ClassicalOrthogonalPolynomials.jl/blob/ba1bf45b02b7132e10db3d283242e69302f2ed8e/src/classical/chebyshev.jl#L23-L28">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ClassicalOrthogonalPolynomials.chebyshevt"><a class="docstring-binding" href="#ClassicalOrthogonalPolynomials.chebyshevt"><code>ClassicalOrthogonalPolynomials.chebyshevt</code></a> â€” <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs"> chebyshevt(n, z)</code></pre><p>computes the <code>n</code>-th Chebyshev polynomial of the first kind at <code>z</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaApproximation/ClassicalOrthogonalPolynomials.jl/blob/ba1bf45b02b7132e10db3d283242e69302f2ed8e/src/classical/chebyshev.jl#L61-L65">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ClassicalOrthogonalPolynomials.chebyshevu"><a class="docstring-binding" href="#ClassicalOrthogonalPolynomials.chebyshevu"><code>ClassicalOrthogonalPolynomials.chebyshevu</code></a> â€” <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs"> chebyshevt(n, z)</code></pre><p>computes the <code>n</code>-th Chebyshev polynomial of the second kind at <code>z</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaApproximation/ClassicalOrthogonalPolynomials.jl/blob/ba1bf45b02b7132e10db3d283242e69302f2ed8e/src/classical/chebyshev.jl#L67-L71">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ClassicalOrthogonalPolynomials.Legendre"><a class="docstring-binding" href="#ClassicalOrthogonalPolynomials.Legendre"><code>ClassicalOrthogonalPolynomials.Legendre</code></a> â€” <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">Legendre{T=Float64}(a,b)</code></pre><p>The quasi-matrix representing Legendre polynomials, where the first axes represents the interval and the second axes represents the polynomial index (starting from 1). See also <a href="#ClassicalOrthogonalPolynomials.legendre"><code>legendre</code></a>, <a href="#ClassicalOrthogonalPolynomials.legendrep"><code>legendrep</code></a>, <a href="#ClassicalOrthogonalPolynomials.LegendreWeight"><code>LegendreWeight</code></a> and <a href="#ClassicalOrthogonalPolynomials.Jacobi"><code>Jacobi</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; P = Legendre()
Legendre()

julia&gt; typeof(P) # default eltype
Legendre{Float64}

julia&gt; axes(P)
(Inclusion(-1.0 .. 1.0 (Chebyshev)), OneToInf())

julia&gt; P[0,:] # Values of polynomials at x=0
â„µâ‚€-element view(::Legendre{Float64}, 0.0, :) with eltype Float64 with indices OneToInf():
  1.0
  0.0
 -0.5
 -0.0
  0.375
  0.0
 -0.3125
 -0.0
  0.2734375
  0.0
  â‹®

julia&gt; Pâ‚€=P[:,1]; # Pâ‚€ is the first Legendre polynomial which is constant.

julia&gt; Pâ‚€[0],Pâ‚€[0.5]
(1.0, 1.0)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaApproximation/ClassicalOrthogonalPolynomials.jl/blob/ba1bf45b02b7132e10db3d283242e69302f2ed8e/src/classical/legendre.jl#L80-L114">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ClassicalOrthogonalPolynomials.legendrep"><a class="docstring-binding" href="#ClassicalOrthogonalPolynomials.legendrep"><code>ClassicalOrthogonalPolynomials.legendrep</code></a> â€” <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs"> legendrep(n, z)</code></pre><p>computes the <code>n</code>-th Legendre polynomial at <code>z</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaApproximation/ClassicalOrthogonalPolynomials.jl/blob/ba1bf45b02b7132e10db3d283242e69302f2ed8e/src/classical/legendre.jl#L159-L163">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ClassicalOrthogonalPolynomials.Jacobi"><a class="docstring-binding" href="#ClassicalOrthogonalPolynomials.Jacobi"><code>ClassicalOrthogonalPolynomials.Jacobi</code></a> â€” <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">Jacobi{T}(a,b)
Jacobi(a,b)</code></pre><p>The quasi-matrix representing Jacobi polynomials, where the first axes represents the interval and the second axes represents the polynomial index (starting from 1). See also <a href="#ClassicalOrthogonalPolynomials.jacobi"><code>jacobi</code></a>, <a href="#ClassicalOrthogonalPolynomials.jacobip"><code>jacobip</code></a> and <a href="#ClassicalOrthogonalPolynomials.JacobiWeight"><code>JacobiWeight</code></a>.</p><p>The eltype, when not specified, will be converted to a floating point data type.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; J=Jacobi(0, 0) # The eltype will be converted to float
Jacobi(0, 0)

julia&gt; axes(J)
(Inclusion(-1.0 .. 1.0 (Chebyshev)), OneToInf())

julia&gt; J[0,:] # Values of polynomials at x=0
â„µâ‚€-element view(::Jacobi{Float64, Int64}, 0.0, :) with eltype Float64 with indices OneToInf():
  1.0
  0.0
 -0.5
 -0.0
  0.375
  0.0
 -0.3125
 -0.0
  0.2734375
  0.0
  â‹®

julia&gt; J0=J[:,1]; # J0 is the first Jacobi polynomial which is constant.

julia&gt; J0[0],J0[0.5]
(1.0, 1.0)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaApproximation/ClassicalOrthogonalPolynomials.jl/blob/ba1bf45b02b7132e10db3d283242e69302f2ed8e/src/classical/jacobi.jl#L117-L151">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ClassicalOrthogonalPolynomials.jacobip"><a class="docstring-binding" href="#ClassicalOrthogonalPolynomials.jacobip"><code>ClassicalOrthogonalPolynomials.jacobip</code></a> â€” <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs"> jacobip(n, a, b, z)</code></pre><p>computes the <code>n</code>-th Jacobi polynomial, orthogonal with respec to <code>(1-x)^a*(1+x)^b</code>, at <code>z</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaApproximation/ClassicalOrthogonalPolynomials.jl/blob/ba1bf45b02b7132e10db3d283242e69302f2ed8e/src/classical/jacobi.jl#L202-L207">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ClassicalOrthogonalPolynomials.laguerrel"><a class="docstring-binding" href="#ClassicalOrthogonalPolynomials.laguerrel"><code>ClassicalOrthogonalPolynomials.laguerrel</code></a> â€” <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs"> laguerrel(n, Î±, z)</code></pre><p>computes the <code>n</code>-th generalized Laguerre polynomial, orthogonal with  respec to <code>x^Î± * exp(-x)</code>, at <code>z</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaApproximation/ClassicalOrthogonalPolynomials.jl/blob/ba1bf45b02b7132e10db3d283242e69302f2ed8e/src/classical/laguerre.jl#L42-L47">source</a></section><section><div><pre><code class="language-julia hljs"> laguerrel(n, z)</code></pre><p>computes the <code>n</code>-th Laguerre polynomial, orthogonal with  respec to <code>exp(-x)</code>, at <code>z</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaApproximation/ClassicalOrthogonalPolynomials.jl/blob/ba1bf45b02b7132e10db3d283242e69302f2ed8e/src/classical/laguerre.jl#L50-L55">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ClassicalOrthogonalPolynomials.hermiteh"><a class="docstring-binding" href="#ClassicalOrthogonalPolynomials.hermiteh"><code>ClassicalOrthogonalPolynomials.hermiteh</code></a> â€” <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs"> hermiteh(n, z)</code></pre><p>computes the <code>n</code>-th Hermite polynomial, orthogonal with  respec to <code>exp(-x^2)</code>, at <code>z</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaApproximation/ClassicalOrthogonalPolynomials.jl/blob/ba1bf45b02b7132e10db3d283242e69302f2ed8e/src/classical/hermite.jl#L43-L48">source</a></section></details></article><h3 id="Weights"><a class="docs-heading-anchor" href="#Weights">Weights</a><a id="Weights-1"></a><a class="docs-heading-anchor-permalink" href="#Weights" title="Permalink"></a></h3><article><details class="docstring" open="true"><summary id="ClassicalOrthogonalPolynomials.OrthonormalWeighted"><a class="docstring-binding" href="#ClassicalOrthogonalPolynomials.OrthonormalWeighted"><code>ClassicalOrthogonalPolynomials.OrthonormalWeighted</code></a> â€” <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">OrthonormalWeighted(P)</code></pre><p>is the orthonormal with respect to L^2 basis given by <code>sqrt.(orthogonalityweight(P)) .* Normalized(P)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaApproximation/ClassicalOrthogonalPolynomials.jl/blob/ba1bf45b02b7132e10db3d283242e69302f2ed8e/src/normalized.jl#L210-L215">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ClassicalOrthogonalPolynomials.HermiteWeight"><a class="docstring-binding" href="#ClassicalOrthogonalPolynomials.HermiteWeight"><code>ClassicalOrthogonalPolynomials.HermiteWeight</code></a> â€” <span class="docstring-category">Type</span></summary><section><div><p>HermiteWeight()</p><p>is a quasi-vector representing <code>exp(-x^2)</code> on â„.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaApproximation/ClassicalOrthogonalPolynomials.jl/blob/ba1bf45b02b7132e10db3d283242e69302f2ed8e/src/classical/hermite.jl#L1-L5">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ClassicalOrthogonalPolynomials.Weighted"><a class="docstring-binding" href="#ClassicalOrthogonalPolynomials.Weighted"><code>ClassicalOrthogonalPolynomials.Weighted</code></a> â€” <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">Weighted(P)</code></pre><p>is equivalent to <code>orthogonalityweight(P) .* P</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaApproximation/ClassicalOrthogonalPolynomials.jl/blob/ba1bf45b02b7132e10db3d283242e69302f2ed8e/src/normalized.jl#L238-L242">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ClassicalOrthogonalPolynomials.LegendreWeight"><a class="docstring-binding" href="#ClassicalOrthogonalPolynomials.LegendreWeight"><code>ClassicalOrthogonalPolynomials.LegendreWeight</code></a> â€” <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">LegendreWeight{T}()
LegendreWeight()</code></pre><p>The quasi-vector representing the Legendre weight function (const 1) on [-1,1]. See also <a href="#ClassicalOrthogonalPolynomials.legendreweight"><code>legendreweight</code></a> and <a href="#ClassicalOrthogonalPolynomials.Legendre"><code>Legendre</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; w = LegendreWeight()
LegendreWeight{Float64}()

julia&gt; w[0.5]
1.0

julia&gt; axes(w)
(Inclusion(-1.0 .. 1.0 (Chebyshev)),)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaApproximation/ClassicalOrthogonalPolynomials.jl/blob/ba1bf45b02b7132e10db3d283242e69302f2ed8e/src/classical/legendre.jl#L1-L17">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ClassicalOrthogonalPolynomials.ChebyshevWeight"><a class="docstring-binding" href="#ClassicalOrthogonalPolynomials.ChebyshevWeight"><code>ClassicalOrthogonalPolynomials.ChebyshevWeight</code></a> â€” <span class="docstring-category">Type</span></summary><section><div><p>ChebyshevWeight{kind,T}()</p><p>is a quasi-vector representing the Chebyshev weight of the specified kind on -1..1. That is, <code>ChebyshevWeight{1}()</code> represents <code>1/sqrt(1-x^2)</code>, and <code>ChebyshevWeight{2}()</code> represents <code>sqrt(1-x^2)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaApproximation/ClassicalOrthogonalPolynomials.jl/blob/ba1bf45b02b7132e10db3d283242e69302f2ed8e/src/classical/chebyshev.jl#L1-L7">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ClassicalOrthogonalPolynomials.JacobiWeight"><a class="docstring-binding" href="#ClassicalOrthogonalPolynomials.JacobiWeight"><code>ClassicalOrthogonalPolynomials.JacobiWeight</code></a> â€” <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">JacobiWeight{T}(a,b)
JacobiWeight(a,b)</code></pre><p>The quasi-vector representing the Jacobi weight function <span>$(1-x)^a (1+x)^b$</span> on <span>$[-1,1]$</span>. See also <a href="#ClassicalOrthogonalPolynomials.jacobiweight"><code>jacobiweight</code></a> and <a href="#ClassicalOrthogonalPolynomials.Jacobi"><code>Jacobi</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; J=JacobiWeight(1.0,1.0)
(1-x)^1.0 * (1+x)^1.0 on -1..1

julia&gt; J[0.5]
0.75

julia&gt; axes(J)
(Inclusion(-1.0 .. 1.0 (Chebyshev)),)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaApproximation/ClassicalOrthogonalPolynomials.jl/blob/ba1bf45b02b7132e10db3d283242e69302f2ed8e/src/classical/jacobi.jl#L24-L40">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ClassicalOrthogonalPolynomials.LaguerreWeight"><a class="docstring-binding" href="#ClassicalOrthogonalPolynomials.LaguerreWeight"><code>ClassicalOrthogonalPolynomials.LaguerreWeight</code></a> â€” <span class="docstring-category">Type</span></summary><section><div><p>LaguerreWeight(Î±)</p><p>is a quasi-vector representing <code>x^Î± * exp(-x)</code> on <code>0..Inf</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaApproximation/ClassicalOrthogonalPolynomials.jl/blob/ba1bf45b02b7132e10db3d283242e69302f2ed8e/src/classical/laguerre.jl#L1-L5">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ClassicalOrthogonalPolynomials.HalfWeighted"><a class="docstring-binding" href="#ClassicalOrthogonalPolynomials.HalfWeighted"><code>ClassicalOrthogonalPolynomials.HalfWeighted</code></a> â€” <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">HalfWeighted{lr}(Jacobi(a,b))</code></pre><p>is equivalent to <code>JacobiWeight(a,0) .* Jacobi(a,b)</code> (<code>lr = :a</code>) or <code>JacobiWeight(0,b) .* Jacobi(a,b)</code> (<code>lr = :b</code>)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaApproximation/ClassicalOrthogonalPolynomials.jl/blob/ba1bf45b02b7132e10db3d283242e69302f2ed8e/src/classical/jacobi.jl#L216-L221">source</a></section></details></article><h3 id="Affine-mapped"><a class="docs-heading-anchor" href="#Affine-mapped">Affine-mapped</a><a id="Affine-mapped-1"></a><a class="docs-heading-anchor-permalink" href="#Affine-mapped" title="Permalink"></a></h3><article><details class="docstring" open="true"><summary id="ClassicalOrthogonalPolynomials.legendre"><a class="docstring-binding" href="#ClassicalOrthogonalPolynomials.legendre"><code>ClassicalOrthogonalPolynomials.legendre</code></a> â€” <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">legendre(d::AbstractInterval)</code></pre><p>The <a href="#ClassicalOrthogonalPolynomials.Legendre"><code>Legendre</code></a> polynomials affine-mapped to interval <code>d</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; P = legendre(0..1)
Legendre() affine mapped to 0 .. 1

julia&gt; axes(P)
(Inclusion(0 .. 1), OneToInf())

julia&gt; P[0.5,:]
â„µâ‚€-element view(::Legendre{Float64}, 0.0, :) with eltype Float64 with indices OneToInf():
  1.0
  0.0
 -0.5
 -0.0
  0.375
  0.0
 -0.3125
 -0.0
  0.2734375
  0.0
  â‹®</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaApproximation/ClassicalOrthogonalPolynomials.jl/blob/ba1bf45b02b7132e10db3d283242e69302f2ed8e/src/classical/legendre.jl#L126-L153">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ClassicalOrthogonalPolynomials.jacobi"><a class="docstring-binding" href="#ClassicalOrthogonalPolynomials.jacobi"><code>ClassicalOrthogonalPolynomials.jacobi</code></a> â€” <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">jacobi(a,b, d::AbstractInterval)</code></pre><p>The <a href="#ClassicalOrthogonalPolynomials.Jacobi"><code>Jacobi</code></a> polynomials affine-mapped to interval <code>d</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; J = jacobi(1, 1, 0..1)
Jacobi(1, 1) affine mapped to 0 .. 1

julia&gt; axes(J)
(Inclusion(0 .. 1), OneToInf())

julia&gt; J[0,:]
â„µâ‚€-element view(::Jacobi{Float64, Int64}, -1.0, :) with eltype Float64 with indices OneToInf():
   1.0
  -2.0
   3.0
  -4.0
   5.0
  -6.0
   7.0
  -8.0
   9.0
 -10.0
   â‹®</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaApproximation/ClassicalOrthogonalPolynomials.jl/blob/ba1bf45b02b7132e10db3d283242e69302f2ed8e/src/classical/jacobi.jl#L165-L192">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ClassicalOrthogonalPolynomials.legendreweight"><a class="docstring-binding" href="#ClassicalOrthogonalPolynomials.legendreweight"><code>ClassicalOrthogonalPolynomials.legendreweight</code></a> â€” <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">legendreweight(d::AbstractInterval)</code></pre><p>The <a href="#ClassicalOrthogonalPolynomials.LegendreWeight"><code>LegendreWeight</code></a> affine-mapped to interval <code>d</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; w = legendreweight(0..1)
LegendreWeight{Float64}() affine mapped to 0 .. 1

julia&gt; axes(w)
(Inclusion(0 .. 1),)

julia&gt; w[0]
1.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaApproximation/ClassicalOrthogonalPolynomials.jl/blob/ba1bf45b02b7132e10db3d283242e69302f2ed8e/src/classical/legendre.jl#L21-L37">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ClassicalOrthogonalPolynomials.jacobiweight"><a class="docstring-binding" href="#ClassicalOrthogonalPolynomials.jacobiweight"><code>ClassicalOrthogonalPolynomials.jacobiweight</code></a> â€” <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">jacobiweight(a,b, d::AbstractInterval)</code></pre><p>The <a href="#ClassicalOrthogonalPolynomials.JacobiWeight"><code>JacobiWeight</code></a> affine-mapped to interval <code>d</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; J = jacobiweight(1, 1, 0..1)
(1-x)^1 * (1+x)^1 on -1..1 affine mapped to 0 .. 1

julia&gt; axes(J)
(Inclusion(0 .. 1),)

julia&gt; J[0.5]
1.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaApproximation/ClassicalOrthogonalPolynomials.jl/blob/ba1bf45b02b7132e10db3d283242e69302f2ed8e/src/classical/jacobi.jl#L52-L68">source</a></section></details></article><h3 id="Recurrences"><a class="docs-heading-anchor" href="#Recurrences">Recurrences</a><a id="Recurrences-1"></a><a class="docs-heading-anchor-permalink" href="#Recurrences" title="Permalink"></a></h3><article><details class="docstring" open="true"><summary id="ClassicalOrthogonalPolynomials.normalizationconstant"><a class="docstring-binding" href="#ClassicalOrthogonalPolynomials.normalizationconstant"><code>ClassicalOrthogonalPolynomials.normalizationconstant</code></a> â€” <span class="docstring-category">Function</span></summary><section><div><p>normalizationconstant</p><p>gives the normalization constants so that the jacobi matrix is symmetric, that is, so we have orthonormal OPs:</p><pre><code class="nohighlight hljs">Q == P*normalizationconstant(P)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaApproximation/ClassicalOrthogonalPolynomials.jl/blob/ba1bf45b02b7132e10db3d283242e69302f2ed8e/src/normalized.jl#L1-L8">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ClassicalOrthogonalPolynomials.OrthogonalPolynomialRatio"><a class="docstring-binding" href="#ClassicalOrthogonalPolynomials.OrthogonalPolynomialRatio"><code>ClassicalOrthogonalPolynomials.OrthogonalPolynomialRatio</code></a> â€” <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">OrthogonalPolynomialRatio(P,x)</code></pre><p>is a is equivalent to the vector <code>P[x,:] ./ P[x,2:end]</code><code>but built from the recurrence coefficients of</code>P`.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaApproximation/ClassicalOrthogonalPolynomials.jl/blob/ba1bf45b02b7132e10db3d283242e69302f2ed8e/src/ratios.jl#L1-L6">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ClassicalOrthogonalPolynomials.singularities"><a class="docstring-binding" href="#ClassicalOrthogonalPolynomials.singularities"><code>ClassicalOrthogonalPolynomials.singularities</code></a> â€” <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">singularities(f)</code></pre><p>gives the singularity structure of an expansion, e.g., <code>JacobiWeight</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaApproximation/ClassicalOrthogonalPolynomials.jl/blob/ba1bf45b02b7132e10db3d283242e69302f2ed8e/src/ClassicalOrthogonalPolynomials.jl#L207-L212">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ClassicalOrthogonalPolynomials.jacobimatrix"><a class="docstring-binding" href="#ClassicalOrthogonalPolynomials.jacobimatrix"><code>ClassicalOrthogonalPolynomials.jacobimatrix</code></a> â€” <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">jacobimatrix(P)</code></pre><p>returns the Jacobi matrix <code>X</code> associated to a quasi-matrix of orthogonal polynomials satisfying</p><pre><code class="language-julia hljs">x = axes(P,1)
x*P == P*X</code></pre><p>Note that <code>X</code> is the transpose of the usual definition of the Jacobi matrix.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaApproximation/ClassicalOrthogonalPolynomials.jl/blob/ba1bf45b02b7132e10db3d283242e69302f2ed8e/src/ClassicalOrthogonalPolynomials.jl#L135-L145">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ClassicalOrthogonalPolynomials.recurrencecoefficients"><a class="docstring-binding" href="#ClassicalOrthogonalPolynomials.recurrencecoefficients"><code>ClassicalOrthogonalPolynomials.recurrencecoefficients</code></a> â€” <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">recurrencecoefficients(P)</code></pre><p>returns a <code>(A,B,C)</code> associated with the Orthogonal Polynomials P, satisfying for <code>x in axes(P,1)</code></p><pre><code class="language-julia hljs">P[x,2] == (A[1]*x + B[1])*P[x,1]
P[x,n+1] == (A[n]*x + B[n])*P[x,n] - C[n]*P[x,n-1]</code></pre><p>Note that <code>C[1]</code>` is unused.</p><p>The relationship with the Jacobi matrix is:</p><pre><code class="language-julia hljs">1/A[n] == X[n+1,n]
-B[n]/A[n] == X[n,n]
C[n+1]/A[n+1] == X[n,n+1]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaApproximation/ClassicalOrthogonalPolynomials.jl/blob/ba1bf45b02b7132e10db3d283242e69302f2ed8e/src/ClassicalOrthogonalPolynomials.jl#L178-L195">source</a></section></details></article><h3 id="Internal"><a class="docs-heading-anchor" href="#Internal">Internal</a><a id="Internal-1"></a><a class="docs-heading-anchor-permalink" href="#Internal" title="Permalink"></a></h3><article><details class="docstring" open="true"><summary id="ClassicalOrthogonalPolynomials.ShuffledFFT"><a class="docstring-binding" href="#ClassicalOrthogonalPolynomials.ShuffledFFT"><code>ClassicalOrthogonalPolynomials.ShuffledFFT</code></a> â€” <span class="docstring-category">Type</span></summary><section><div><p>Gives a shuffled version of the FFT, with order 1,exp(-im<em>Î¸),exp(im</em>Î¸),exp(-2im*Î¸)â€¦</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaApproximation/ClassicalOrthogonalPolynomials.jl/blob/ba1bf45b02b7132e10db3d283242e69302f2ed8e/src/classical/fourier.jl#L48-L51">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ClassicalOrthogonalPolynomials.ShuffledIFFT"><a class="docstring-binding" href="#ClassicalOrthogonalPolynomials.ShuffledIFFT"><code>ClassicalOrthogonalPolynomials.ShuffledIFFT</code></a> â€” <span class="docstring-category">Type</span></summary><section><div><p>Gives a shuffled version of the IFFT, with order 1,exp(-im<em>Î¸),exp(im</em>Î¸),exp(-2im*Î¸)â€¦</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaApproximation/ClassicalOrthogonalPolynomials.jl/blob/ba1bf45b02b7132e10db3d283242e69302f2ed8e/src/classical/fourier.jl#L56-L59">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ClassicalOrthogonalPolynomials.ShuffledR2HC"><a class="docstring-binding" href="#ClassicalOrthogonalPolynomials.ShuffledR2HC"><code>ClassicalOrthogonalPolynomials.ShuffledR2HC</code></a> â€” <span class="docstring-category">Type</span></summary><section><div><p>Gives a shuffled version of the real FFT, with order 1,sin(Î¸),cos(Î¸),sin(2Î¸)â€¦</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaApproximation/ClassicalOrthogonalPolynomials.jl/blob/ba1bf45b02b7132e10db3d283242e69302f2ed8e/src/classical/fourier.jl#L32-L35">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ClassicalOrthogonalPolynomials.ShuffledIR2HC"><a class="docstring-binding" href="#ClassicalOrthogonalPolynomials.ShuffledIR2HC"><code>ClassicalOrthogonalPolynomials.ShuffledIR2HC</code></a> â€” <span class="docstring-category">Type</span></summary><section><div><p>Gives a shuffled version of the real IFFT, with order 1,sin(Î¸),cos(Î¸),sin(2Î¸)â€¦</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaApproximation/ClassicalOrthogonalPolynomials.jl/blob/ba1bf45b02b7132e10db3d283242e69302f2ed8e/src/classical/fourier.jl#L40-L43">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ClassicalOrthogonalPolynomials.qr_jacobimatrix"><a class="docstring-binding" href="#ClassicalOrthogonalPolynomials.qr_jacobimatrix"><code>ClassicalOrthogonalPolynomials.qr_jacobimatrix</code></a> â€” <span class="docstring-category">Function</span></summary><section><div><p>qr_jacobimatrix(w, P)</p><p>returns the Jacobi matrix <code>X</code> associated to a quasi-matrix of polynomials orthogonal with respect to <code>w(x)</code> by computing a QR decomposition of the square root weight modification.</p><p>The resulting polynomials are orthonormal on the same domain as <code>P</code>. The supplied <code>P</code> must be normalized. Accepted inputs for <code>w</code> are the target weight as a function or <code>sqrtW</code>, representing the multiplication operator of square root weight modification on the basis <code>P</code>.</p><p>The underlying QR approach allows two methods, one which uses the Q matrix and one which uses the R matrix. To change between methods, an optional argument :Q or :R may be supplied. The default is to use the Q method.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaApproximation/ClassicalOrthogonalPolynomials.jl/blob/ba1bf45b02b7132e10db3d283242e69302f2ed8e/src/choleskyQR.jl#L69-L78">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ClassicalOrthogonalPolynomials.cholesky_jacobimatrix"><a class="docstring-binding" href="#ClassicalOrthogonalPolynomials.cholesky_jacobimatrix"><code>ClassicalOrthogonalPolynomials.cholesky_jacobimatrix</code></a> â€” <span class="docstring-category">Function</span></summary><section><div><p>cholesky_jacobimatrix(w, P)</p><p>returns the Jacobi matrix <code>X</code> associated to a quasi-matrix of polynomials orthogonal with respect to <code>w(x)</code> by computing a Cholesky decomposition of the weight modification.</p><p>The resulting polynomials are orthonormal on the same domain as <code>P</code>. The supplied <code>P</code> must be normalized. Accepted inputs are <code>w</code> as a function or <code>W</code> as an infinite matrix representing the weight modifier multiplication by the function <code>w / w_P</code> on <code>P</code> where <code>w_P</code> is the orthogonality weight of <code>P</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaApproximation/ClassicalOrthogonalPolynomials.jl/blob/ba1bf45b02b7132e10db3d283242e69302f2ed8e/src/choleskyQR.jl#L47-L54">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ClassicalOrthogonalPolynomials.AbstractNormalizedOPLayout"><a class="docstring-binding" href="#ClassicalOrthogonalPolynomials.AbstractNormalizedOPLayout"><code>ClassicalOrthogonalPolynomials.AbstractNormalizedOPLayout</code></a> â€” <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">AbstractNormalizedOPLayout</code></pre><p>represents OPs that are of the form P * R where P is another family of OPs and R is upper-triangular.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaApproximation/ClassicalOrthogonalPolynomials.jl/blob/ba1bf45b02b7132e10db3d283242e69302f2ed8e/src/normalized.jl#L32-L36">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ClassicalOrthogonalPolynomials.MappedOPLayout"><a class="docstring-binding" href="#ClassicalOrthogonalPolynomials.MappedOPLayout"><code>ClassicalOrthogonalPolynomials.MappedOPLayout</code></a> â€” <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">MappedOPLayout</code></pre><p>represents an OP that is (usually affine) mapped OP</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaApproximation/ClassicalOrthogonalPolynomials.jl/blob/ba1bf45b02b7132e10db3d283242e69302f2ed8e/src/ClassicalOrthogonalPolynomials.jl#L79-L83">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ClassicalOrthogonalPolynomials.WeightedOPLayout"><a class="docstring-binding" href="#ClassicalOrthogonalPolynomials.WeightedOPLayout"><code>ClassicalOrthogonalPolynomials.WeightedOPLayout</code></a> â€” <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">WeightedOPLayout</code></pre><p>represents an OP multiplied by its orthogonality weight.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaApproximation/ClassicalOrthogonalPolynomials.jl/blob/ba1bf45b02b7132e10db3d283242e69302f2ed8e/src/ClassicalOrthogonalPolynomials.jl#L86-L90">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ClassicalOrthogonalPolynomials.legendre_grammatrix"><a class="docstring-binding" href="#ClassicalOrthogonalPolynomials.legendre_grammatrix"><code>ClassicalOrthogonalPolynomials.legendre_grammatrix</code></a> â€” <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">legendre_grammatrix</code></pre><p>computes the grammatrix by first re-expanding in Legendre</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaApproximation/ClassicalOrthogonalPolynomials.jl/blob/ba1bf45b02b7132e10db3d283242e69302f2ed8e/src/classical/legendre.jl#L198-L202">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ClassicalOrthogonalPolynomials.weightedgrammatrix"><a class="docstring-binding" href="#ClassicalOrthogonalPolynomials.weightedgrammatrix"><code>ClassicalOrthogonalPolynomials.weightedgrammatrix</code></a> â€” <span class="docstring-category">Function</span></summary><section><div><p>gives the inner products of OPs with their weight, i.e., Weighted(P)&#39;P.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaApproximation/ClassicalOrthogonalPolynomials.jl/blob/ba1bf45b02b7132e10db3d283242e69302f2ed8e/src/ClassicalOrthogonalPolynomials.jl#L253-L255">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ClassicalOrthogonalPolynomials.interlace!"><a class="docstring-binding" href="#ClassicalOrthogonalPolynomials.interlace!"><code>ClassicalOrthogonalPolynomials.interlace!</code></a> â€” <span class="docstring-category">Function</span></summary><section><div><p>This function implements the algorithm described in:</p><pre><code class="nohighlight hljs">P. Jain, &quot;A simple in-place algorithm for in-shuffle,&quot; arXiv:0805.1598, 2008.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaApproximation/ClassicalOrthogonalPolynomials.jl/blob/ba1bf45b02b7132e10db3d283242e69302f2ed8e/src/interlace.jl#L63-L67">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ClassicalOrthogonalPolynomials._tritrunc"><a class="docstring-binding" href="#ClassicalOrthogonalPolynomials._tritrunc"><code>ClassicalOrthogonalPolynomials._tritrunc</code></a> â€” <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">_tritrunc(X,n)</code></pre><p>does a square truncation of a tridiagonal matrix.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaApproximation/ClassicalOrthogonalPolynomials.jl/blob/ba1bf45b02b7132e10db3d283242e69302f2ed8e/src/ClassicalOrthogonalPolynomials.jl#L151-L155">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ClassicalOrthogonalPolynomials.SetindexInterlace"><a class="docstring-binding" href="#ClassicalOrthogonalPolynomials.SetindexInterlace"><code>ClassicalOrthogonalPolynomials.SetindexInterlace</code></a> â€” <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">SetindexInterlace(z, args...)</code></pre><p>is an analogue of <code>Basis</code> for vector that replaces the <code>i</code>th index of <code>z</code>, takes the union of the first axis, and the second axis is a blocked interlace of args.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaApproximation/ClassicalOrthogonalPolynomials.jl/blob/ba1bf45b02b7132e10db3d283242e69302f2ed8e/src/interlace.jl#L128-L135">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ClassicalOrthogonalPolynomials.ConvertedOrthogonalPolynomial"><a class="docstring-binding" href="#ClassicalOrthogonalPolynomials.ConvertedOrthogonalPolynomial"><code>ClassicalOrthogonalPolynomials.ConvertedOrthogonalPolynomial</code></a> â€” <span class="docstring-category">Type</span></summary><section><div><p>Represents orthonormal polynomials defined via a conversion operator from P, that is, Q = P * inv(U).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaApproximation/ClassicalOrthogonalPolynomials.jl/blob/ba1bf45b02b7132e10db3d283242e69302f2ed8e/src/choleskyQR.jl#L1-L3">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ClassicalOrthogonalPolynomials.PiecewiseInterlace"><a class="docstring-binding" href="#ClassicalOrthogonalPolynomials.PiecewiseInterlace"><code>ClassicalOrthogonalPolynomials.PiecewiseInterlace</code></a> â€” <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">PiecewiseInterlace(args...)</code></pre><p>is an analogue of <code>Basis</code> that takes the union of the first axis, and the second axis is a blocked interlace of args. If there is overlap, it uses the first in order.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaApproximation/ClassicalOrthogonalPolynomials.jl/blob/ba1bf45b02b7132e10db3d283242e69302f2ed8e/src/interlace.jl#L105-L111">source</a></section></details></article></article><nav class="docs-footer"><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.16.1 on <span class="colophon-date" title="Sunday 14 December 2025 07:34">Sunday 14 December 2025</span>. Using Julia version 1.10.10.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
