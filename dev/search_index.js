var documenterSearchIndex = {"docs":
[{"location":"#ClassicalOrthogonalPolynomials.jl","page":"Home","title":"ClassicalOrthogonalPolynomials.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"A Julia package for classical orthogonal polynomials and expansions","category":"page"},{"location":"#Definitions","page":"Home","title":"Definitions","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"We follow the Digital Library of Mathematical Functions, which defines the following classical orthogonal polynomials:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Legendre: P_n(x)\nChebyshev (1st kind, 2nd kind): T_n(x), U_n(x)\nUltraspherical: C_n^(Î»)(x)\nJacobi: P_n^(ab)(x)\nLaguerre: L_n^(Î±)(x)\nHermite: H_n(x)","category":"page"},{"location":"#Evaluation","page":"Home","title":"Evaluation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The simplest usage of this package is to evaluate classical orthogonal polynomials:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> using ClassicalOrthogonalPolynomials\n\njulia> n, x = 5, 0.1;\n\njulia> legendrep(n, x) # P_n(x)\n0.17882875\n\njulia> chebyshevt(n, x) # T_n(x) == cos(n*acos(x))\n0.48016\n\njulia> chebyshevu(n, x) # U_n(x) == sin((n+1)*acos(x))/sin(acos(x))\n0.56832\n\njulia> Î» = 0.3; ultrasphericalc(n, Î», x) # C_n^(Î»)(x)\n0.08578714248\n\njulia> a,b = 0.1,0.2; jacobip(n, a, b, x) # P_n^(a,b)(x)\n0.17459116797117194\n\njulia> laguerrel(n, x) # L_n(x)\n0.5483540833333331\n\njulia> Î± = 0.1; laguerrel(n, Î±, x) # L_n^(Î±)(x)\n0.732916666666666\n\njulia> hermiteh(n, x) # H_n(x)\n11.84032","category":"page"},{"location":"#Continuum-arrays","page":"Home","title":"Continuum arrays","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"For expansions, recurrence relationships, and other operations linked with linear equations, it is useful to treat the families of orthogonal  polynomials as continuum arrays, as implemented in ContinuumArrays.jl. The continuum arrays implementation is accessed as follows:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> T = ChebyshevT() # Or just Chebyshev()\nChebyshevT()\n\njulia> axes(T) # [-1,1] by 1:âˆž\n(Inclusion(-1.0..1.0 (Chebyshev)), OneToInf())\n\njulia> T[x, n+1] # T_n(x) = cos(n*acos(x))\n0.48016","category":"page"},{"location":"","page":"Home","title":"Home","text":"We can thereby access many points and indices efficiently using array-like language:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> x = range(-1, 1; length=1000);\n\njulia> T[x, 1:1000] # [T_j(x[k]) for k=1:1000, j=0:999]\n1000Ã—1000 Matrix{Float64}:\n 1.0  -1.0       1.0       -1.0       1.0       -1.0       1.0       â€¦  -1.0        1.0       -1.0        1.0       -1.0\n 1.0  -0.997998  0.992     -0.98203   0.968128  -0.95035   0.928766     -0.99029    0.979515  -0.964818   0.946258  -0.92391\n 1.0  -0.995996  0.984016  -0.964156  0.936575  -0.901494  0.859194     -0.448975   0.367296  -0.282676   0.195792  -0.107341\n 1.0  -0.993994  0.976048  -0.946378  0.90534   -0.853427  0.791262      0.660163  -0.738397   0.807761  -0.867423   0.916664\n 1.0  -0.991992  0.968096  -0.928695  0.874421  -0.806141  0.72495      -0.942051   0.892136  -0.827934   0.750471  -0.660989\n 1.0  -0.98999   0.96016   -0.911108  0.843816  -0.75963   0.660237  â€¦   0.891882  -0.946786   0.982736  -0.999011   0.995286\n 1.0  -0.987988  0.952241  -0.893616  0.813524  -0.713888  0.597101      0.905338  -0.828835   0.73242   -0.618409   0.489542\n â‹®                                               â‹®                   â‹±   â‹®                                          \n 1.0   0.987988  0.952241   0.893616  0.813524   0.713888  0.597101     -0.905338  -0.828835  -0.73242   -0.618409  -0.489542\n 1.0   0.98999   0.96016    0.911108  0.843816   0.75963   0.660237     -0.891882  -0.946786  -0.982736  -0.999011  -0.995286\n 1.0   0.991992  0.968096   0.928695  0.874421   0.806141  0.72495   â€¦   0.942051   0.892136   0.827934   0.750471   0.660989\n 1.0   0.993994  0.976048   0.946378  0.90534    0.853427  0.791262     -0.660163  -0.738397  -0.807761  -0.867423  -0.916664\n 1.0   0.995996  0.984016   0.964156  0.936575   0.901494  0.859194      0.448975   0.367296   0.282676   0.195792   0.107341\n 1.0   0.997998  0.992      0.98203   0.968128   0.95035   0.928766      0.99029    0.979515   0.964818   0.946258   0.92391\n 1.0   1.0       1.0        1.0       1.0        1.0       1.0           1.0        1.0        1.0        1.0        1.0","category":"page"},{"location":"#Expansions","page":"Home","title":"Expansions","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"We view a function expansion in say Chebyshev polynomials in terms of continuum arrays as follows:","category":"page"},{"location":"","page":"Home","title":"Home","text":"f(x) = sum_k=0^ c_k T_k(x) = beginbmatrixT_0(x)  T_1(x)   endbmatrix \nbeginbmatrixc_0 c_1  vdots endbmatrix = Tx * ðœ","category":"page"},{"location":"","page":"Home","title":"Home","text":"To be more precise, we think of functions as continuum-vectors. Here is a simple example:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> f = T * [1; 2; 3; zeros(âˆž)]; # T_0(x) + T_1(x) + T_2(x)\n\njulia> f[0.1]\n-1.74","category":"page"},{"location":"","page":"Home","title":"Home","text":"To find the coefficients for a given function we consider this as the problem of finding ðœ such that T*ðœ == f, that is:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> T \\ f\nvcat(3-element Vector{Float64}, â„µâ‚€-element FillArrays.Zeros{Float64, 1, Tuple{InfiniteArrays.OneToInf{Int64}}} with indices OneToInf()) with indices OneToInf():\n 1.0\n 2.0\n 3.0\n  â‹… \n  â‹… \n  â‹… \n  â‹… \n â‹®","category":"page"},{"location":"","page":"Home","title":"Home","text":"For a function given only pointwise we broadcast over x, e.g., the following are the coefficients of exp(x):","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> x = axes(T, 1);\n\njulia> c = T \\ exp.(x)\nvcat(14-element Vector{Float64}, â„µâ‚€-element FillArrays.Zeros{Float64, 1, Tuple{InfiniteArrays.OneToInf{Int64}}} with indices OneToInf()) with indices OneToInf():\n 1.2660658777520084\n 1.1303182079849703\n 0.27149533953407656\n 0.04433684984866379\n 0.0054742404420936785\n 0.0005429263119139232\n 4.497732295427654e-5\n â‹®\n\njulia> f = T*c; f[0.1] # â‰ˆ exp(0.1)\n1.1051709180756477","category":"page"},{"location":"","page":"Home","title":"Home","text":"With a little cheeky usage of Julia's order-of-operations this can be written succicently as:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> f = T / T \\ exp.(x);\n\njulia> f[0.1]\n1.1051709180756477","category":"page"},{"location":"","page":"Home","title":"Home","text":"(Or for more clarity just write T * (T \\ exp.(x)).)","category":"page"},{"location":"#Jacobi-matrices","page":"Home","title":"Jacobi matrices","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Orthogonal polynomials satisfy well-known three-term recurrences:","category":"page"},{"location":"","page":"Home","title":"Home","text":"x p_n(x) = c_n-1 p_n-1(x) + a_n p_n(x) + b_n p_n+1(x)","category":"page"},{"location":"","page":"Home","title":"Home","text":"In continuum-array language this has the  form of a comuting relationship:","category":"page"},{"location":"","page":"Home","title":"Home","text":"x beginbmatrix p_0  p_1  cdots endbmatrix = beginbmatrix p_0  p_1  cdots endbmatrix beginbmatrix a_0  c_0   b_0  a_1  c_1   b_1  a_2  ddots  ddots  ddots endbmatrix","category":"page"},{"location":"","page":"Home","title":"Home","text":"We can therefore find the Jacobi matrix naturally as follows:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> T \\ (x .* T)\nâ„µâ‚€Ã—â„µâ‚€ LazyBandedMatrices.Tridiagonal{Float64, LazyArrays.ApplyArray{Float64, 1, typeof(vcat), Tuple{Float64, FillArrays.Fill{Float64, 1, Tuple{InfiniteArrays.OneToInf{Int64}}}}}, FillArrays.Zeros{Float64, 1, Tuple{InfiniteArrays.OneToInf{Int64}}}, FillArrays.Fill{Float64, 1, Tuple{InfiniteArrays.OneToInf{Int64}}}} with indices OneToInf()Ã—OneToInf():\n 0.0  0.5   â‹…    â‹…    â‹…    â‹…    â‹…    â‹…    â‹…    â‹…    â‹…    â‹…   â€¦  \n 1.0  0.0  0.5   â‹…    â‹…    â‹…    â‹…    â‹…    â‹…    â‹…    â‹…    â‹…      \n  â‹…   0.5  0.0  0.5   â‹…    â‹…    â‹…    â‹…    â‹…    â‹…    â‹…    â‹…      \n  â‹…    â‹…   0.5  0.0  0.5   â‹…    â‹…    â‹…    â‹…    â‹…    â‹…    â‹…      \n  â‹…    â‹…    â‹…   0.5  0.0  0.5   â‹…    â‹…    â‹…    â‹…    â‹…    â‹…      \n  â‹…    â‹…    â‹…    â‹…   0.5  0.0  0.5   â‹…    â‹…    â‹…    â‹…    â‹…   â€¦  \n  â‹…    â‹…    â‹…    â‹…    â‹…   0.5  0.0  0.5   â‹…    â‹…    â‹…    â‹…      \n â‹®                        â‹®                        â‹®         â‹±  ","category":"page"},{"location":"","page":"Home","title":"Home","text":"Alternatively, just call jacobimatrix(T) (noting its the transpose of the more traditional convention).","category":"page"},{"location":"#Derivatives","page":"Home","title":"Derivatives","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The derivatives of classical orthogonal polynomials are also classical OPs, and this can be seen as follows:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> U = ChebyshevU();\n\njulia> D = Derivative(x);\n\njulia> U\\D*T\nâ„µâ‚€Ã—â„µâ‚€ BandedMatrix{Float64} with bandwidths (-1, 1) with data 1Ã—â„µâ‚€ adjoint(::InfiniteArrays.InfStepRange{Float64, Float64}) with eltype Float64 with indices Base.OneTo(1)Ã—OneToInf() with indices OneToInf()Ã—OneToInf():\n  â‹…   1.0   â‹…    â‹…    â‹…    â‹…    â‹…    â‹…    â‹…    â‹…    â‹…    â‹…   â€¦  \n  â‹…    â‹…   2.0   â‹…    â‹…    â‹…    â‹…    â‹…    â‹…    â‹…    â‹…    â‹…      \n  â‹…    â‹…    â‹…   3.0   â‹…    â‹…    â‹…    â‹…    â‹…    â‹…    â‹…    â‹…      \n  â‹…    â‹…    â‹…    â‹…   4.0   â‹…    â‹…    â‹…    â‹…    â‹…    â‹…    â‹…      \n  â‹…    â‹…    â‹…    â‹…    â‹…   5.0   â‹…    â‹…    â‹…    â‹…    â‹…    â‹…      \n  â‹…    â‹…    â‹…    â‹…    â‹…    â‹…   6.0   â‹…    â‹…    â‹…    â‹…    â‹…   â€¦  \n  â‹…    â‹…    â‹…    â‹…    â‹…    â‹…    â‹…   7.0   â‹…    â‹…    â‹…    â‹…      \n â‹®                        â‹®                        â‹®         â‹±  ","category":"page"},{"location":"","page":"Home","title":"Home","text":"Similarly, the derivative of weighted classical OPs are weighted classical OPs:","category":"page"},{"location":"","page":"Home","title":"Home","text":"lia> Weighted(T)\\D*Weighted(U)\nâ„µâ‚€Ã—â„µâ‚€ BandedMatrix{Float64} with bandwidths (1, -1) with data 1Ã—â„µâ‚€ adjoint(::InfiniteArrays.InfStepRange{Float64, Float64}) with eltype Float64 with indices Base.OneTo(1)Ã—OneToInf() with indices OneToInf()Ã—OneToInf():\n   â‹…     â‹…     â‹…     â‹…     â‹…     â‹…    â‹…    â‹…    â‹…    â‹…    â‹…   â€¦  \n -1.0    â‹…     â‹…     â‹…     â‹…     â‹…    â‹…    â‹…    â‹…    â‹…    â‹…      \n   â‹…   -2.0    â‹…     â‹…     â‹…     â‹…    â‹…    â‹…    â‹…    â‹…    â‹…      \n   â‹…     â‹…   -3.0    â‹…     â‹…     â‹…    â‹…    â‹…    â‹…    â‹…    â‹…      \n   â‹…     â‹…     â‹…   -4.0    â‹…     â‹…    â‹…    â‹…    â‹…    â‹…    â‹…      \n   â‹…     â‹…     â‹…     â‹…   -5.0    â‹…    â‹…    â‹…    â‹…    â‹…    â‹…   â€¦  \n   â‹…     â‹…     â‹…     â‹…     â‹…   -6.0   â‹…    â‹…    â‹…    â‹…    â‹…      \n  â‹®                             â‹®                        â‹®    â‹±  ","category":"page"},{"location":"#Other-recurrence-relationships","page":"Home","title":"Other recurrence relationships","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Many other sparse recurrence relationships are implemented. Here's one:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> U\\T\nâ„µâ‚€Ã—â„µâ‚€ BandedMatrix{Float64} with bandwidths (0, 2) with data vcat(1Ã—â„µâ‚€ FillArrays.Fill{Float64, 2, Tuple{Base.OneTo{Int64}, InfiniteArrays.OneToInf{Int64}}} with indices Base.OneTo(1)Ã—OneToInf(), 1Ã—â„µâ‚€ FillArrays.Zeros{Float64, 2, Tuple{Base.OneTo{Int64}, InfiniteArrays.OneToInf{Int64}}} with indices Base.OneTo(1)Ã—OneToInf(), hcat(1Ã—1 Ones{Float64}, 1Ã—â„µâ‚€ FillArrays.Fill{Float64, 2, Tuple{Base.OneTo{Int64}, InfiniteArrays.OneToInf{Int64}}} with indices Base.OneTo(1)Ã—OneToInf()) with indices Base.OneTo(1)Ã—OneToInf()) with indices Base.OneTo(3)Ã—OneToInf() with indices OneToInf()Ã—OneToInf():\n 1.0  0.0  -0.5    â‹…     â‹…     â‹…     â‹…     â‹…     â‹…    â‹…    â‹…   â€¦  \n  â‹…   0.5   0.0  -0.5    â‹…     â‹…     â‹…     â‹…     â‹…    â‹…    â‹…      \n  â‹…    â‹…    0.5   0.0  -0.5    â‹…     â‹…     â‹…     â‹…    â‹…    â‹…      \n  â‹…    â‹…     â‹…    0.5   0.0  -0.5    â‹…     â‹…     â‹…    â‹…    â‹…      \n  â‹…    â‹…     â‹…     â‹…    0.5   0.0  -0.5    â‹…     â‹…    â‹…    â‹…      \n  â‹…    â‹…     â‹…     â‹…     â‹…    0.5   0.0  -0.5    â‹…    â‹…    â‹…   â€¦  \n  â‹…    â‹…     â‹…     â‹…     â‹…     â‹…    0.5   0.0  -0.5   â‹…    â‹…      \n â‹®                            â‹®                           â‹®    â‹±  ","category":"page"},{"location":"","page":"Home","title":"Home","text":"(Probably best to ignore the type signature ðŸ˜…)","category":"page"}]
}
